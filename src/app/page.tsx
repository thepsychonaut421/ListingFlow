// This file is generated by Firebase Studio
'use client';

import * as React from 'react';
import { useRouter } from 'next/navigation';
import {
  File,
  PlusCircle,
  FilePenLine,
  Download,
  RefreshCw,
  Send,
  Loader2,
  MoreVertical,
  Server,
} from 'lucide-react';

import { Button } from '@/components/ui/button';
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from '@/components/ui/card';
import {
    Sheet,
    SheetContent,
    SheetHeader,
    SheetTitle,
    SheetDescription,
    SheetTrigger
} from '@/components/ui/sheet';
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogDescription,
  DialogTrigger,
} from '@/components/ui/dialog';
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from '@/components/ui/dropdown-menu';
import { Badge } from '@/components/ui/badge';
import type { Product } from '@/lib/types';
import { ProductDataTable } from '@/components/product-data-table';
import { getColumns } from '@/components/product-columns';
import { generateProductDescription } from '@/ai/flows/generate-product-description';
import { findProductDescription } from '@/ai/flows/find-product-description';
import { findTechnicalSpecs } from '@/ai/flows/find-technical-specs';
import { generateProductImage } from '@/ai/flows/generate-product-image';
import { useToast } from '@/hooks/use-toast';
import { ProductForm } from '@/components/product-form';
import { BulkEditForm } from '@/components/bulk-edit-form';
import { useSelectionStore } from '@/stores/selection-store';
import { exportProductsToERPNext } from '@/lib/erpnext';
import { SelectedProducts } from '@/components/selected-products';

const EnvBadge = () => {
    const env = process.env.NEXT_PUBLIC_ENV || 'dev';
    const isProd = env === 'prod';
    return (
        <Badge variant={isProd ? 'destructive' : 'secondary'} className="hidden md:flex items-center gap-2">
            <Server className="h-4 w-4" />
            <span>ERP: {isProd ? 'Production' : 'Development'}</span>
        </Badge>
    );
};

type ListingStatus = Product["listingStatus"];

const asListingStatus = (v: unknown): ListingStatus => {
  switch ((v ?? "").toString().toLowerCase()) {
    case "draft": return "draft";
    case "listed": return "listed";
    case "error": return "error";
    case "new": return "new";
    case "used": return "used";
    case "refurbished": return "refurbished";
    default: return "draft"; // sensible fallback
  }
};


function DashboardClient() {
  const [products, setProducts] = React.useState<Product[]>([]);
  const [isSheetOpen, setIsSheetOpen] = React.useState(false);
  const [isBulkEditDialogOpen, setIsBulkEditDialogOpen] = React.useState(false);
  const [selectedProduct, setSelectedProduct] = React.useState<Product | null>(null);
  const [isLoading, setIsLoading] = React.useState(true);
  const [isErpLoading, setIsErpLoading] = React.useState(false);
  const [generatingProductId, setGeneratingProductId] = React.useState<string | null>(null);
  const { toast } = useToast();
  const router = useRouter();

  const selectedIds = useSelectionStore(state => state.selectedIds);
  const clearSelection = useSelectionStore(state => state.clear);
  const toggleSelection = useSelectionStore(state => state.toggle);

  const selectedProductIds = React.useMemo(() => Array.from(selectedIds), [selectedIds]);
  const selectedProducts = React.useMemo(() => {
    return products.filter(p => selectedIds.has(p.id));
  }, [products, selectedIds]);

  React.useEffect(() => {
    try {
      const storedProducts = localStorage.getItem('listingFlowProducts');
      if (storedProducts) {
        setProducts(JSON.parse(storedProducts));
      } else {
        setProducts([]);
      }
    } catch (error) {
      console.error('Failed to parse products from localStorage', error);
      setProducts([]);
    }
    setIsLoading(false);
  }, []);


  React.useEffect(() => {
    if (!isLoading) {
      try {
        localStorage.setItem('listingFlowProducts', JSON.stringify(products));
      } catch (error) {
        console.error('Failed to save products to localStorage', error);
        toast({
          variant: 'destructive',
          title: 'Save Failed',
          description:
            'Could not save products. Local storage might be full. Please clear some data or images.',
        });
      }
    }
  }, [products, isLoading, toast]);

  const handleAddProduct = () => {
    setSelectedProduct(null);
    setIsSheetOpen(true);
  };

  const handleEditProduct = (product: Product) => {
    setSelectedProduct(product);
    setIsSheetOpen(true);
  };

  const handleDeleteProduct = (id: string) => {
    setProducts(products.filter((p) => p.id !== id));
  };
  
  const handleBulkDelete = (ids: string[]) => {
    setProducts(products.filter((p) => !ids.includes(p.id)));
    clearSelection();
    toast({
        title: 'Products Deleted',
        description: `${ids.length} products have been deleted successfully.`,
    });
  };

  const handleSaveProduct = (productData: Product) => {
    if (selectedProduct) {
        setProducts(products.map((p) => (p.id === productData.id ? productData : p)));
    } else {
        setProducts([
            { ...productData, id: crypto.randomUUID() },
            ...products,
        ]);
    }
    setIsSheetOpen(false);
    setSelectedProduct(null);
  };
  
  const handleUpdateProduct = (id: string, data: Partial<Product>) => {
    setProducts(products.map(p => p.id === id ? { ...p, ...data } : p));
  };

  const handleSaveBulkEdit = (data: Partial<Product>) => {
    setProducts(products.map(p => {
        if (selectedIds.has(p.id)) {
            const updatedProduct = { ...p };
            // Iterate over the keys in the update data object
            for (const key in data) {
                // Check if the key is a property of the data object and its value is not empty or null
                if (Object.prototype.hasOwnProperty.call(data, key) && data[key as keyof typeof data]) {
                    (updatedProduct as any)[key] = data[key as keyof typeof data];
                }
            }
            return updatedProduct;
        }
        return p;
    }));
    toast({
        title: 'Bulk Edit Successful',
        description: `${selectedProductIds.length} products have been updated.`,
    });
    setIsBulkEditDialogOpen(false);
    clearSelection();
  };
  
  const handleGenerateDescription = async (product: Product) => {
    setGeneratingProductId(product.id);
    try {
      const result = await generateProductDescription({
        productName: product.name,
        category: product.category,
        listingStatus: product.listingStatus,
        brand: product.technicalSpecs?.brand as string || product.technicalSpecs?.Marke as string,
      });
      
      handleUpdateProduct(product.id, {
        description: result.description,
        tags: Array.isArray(result.tags) ? result.tags : [],
        keywords: Array.isArray(result.keywords) ? result.keywords : [],
        category: result.category,
        ebayCategoryId: result.ebayCategoryId,
        ean: result.ean,
        technicalSpecs: {
          ...product.technicalSpecs,
          brand: result.brand,
          Produktart: result.productType,
          EAN: result.ean,
        }
      });

      toast({
        title: 'AI Magic Successful!',
        description: `All fields for "${product.name}" have been generated.`,
      });

    } catch (error) {
      console.error('Failed to generate description:', error);
      toast({
        variant: 'destructive',
        title: 'AI Magic Failed',
        description: 'Could not generate data. Please try again.',
      });
    } finally {
      setGeneratingProductId(null);
    }
  };

  const handleCopyDescription = async (product: Product, source: 'otto' | 'ebay') => {
    setGeneratingProductId(product.id);
    try {
      const result = await findProductDescription({
        productName: product.name,
        brand: product.technicalSpecs?.brand as string || product.technicalSpecs?.Marke as string,
        ean: product.ean,
        source: source,
      });
      
      if (result.description || Object.keys(result.technicalSpecs).length > 0) {
        handleUpdateProduct(product.id, { 
          description: result.description,
          technicalSpecs: {
            ...product.technicalSpecs,
            ...result.technicalSpecs
          }
        });
        toast({
          title: 'Content Copied!',
          description: `Description and specs for "${product.name}" have been copied from ${source}.de.`,
        });
      } else {
        toast({
          variant: 'destructive',
          title: 'Copy Failed',
          description: `Could not find content for "${product.name}" on ${source}.de.`,
        });
      }

    } catch (error) {
      console.error(`Failed to copy description from ${source}:`, error);
      toast({
        variant: 'destructive',
        title: 'Copy Failed',
        description: `An error occurred while copying from ${source}.de.`,
      });
    } finally {
      setGeneratingProductId(null);
    }
  };

  const handleExtractTechSpecs = async (product: Product) => {
    setGeneratingProductId(product.id);
    try {
        const result = await findTechnicalSpecs({
            productName: product.name,
            description: product.description,
        });

        if (result.specs && Object.keys(result.specs).length > 0) {
            handleUpdateProduct(product.id, {
                technicalSpecs: {
                    ...product.technicalSpecs,
                    ...result.specs,
                },
            });
            toast({
                title: 'AI Extraction Successful',
                description: `Technical specs for "${product.name}" have been extracted.`,
            });
        } else {
            toast({
                variant: 'destructive',
                title: 'Extraction Failed',
                description: `Could not find any technical specs for "${product.name}".`,
            });
        }
    } catch (error) {
        console.error('Failed to extract tech specs:', error);
        toast({
            variant: 'destructive',
            title: 'AI Extraction Failed',
            description: 'An error occurred while extracting technical specs.',
        });
    } finally {
        setGeneratingProductId(null);
    }
  };
  
    const handleGenerateImage = async (product: Product) => {
    setGeneratingProductId(product.id);
    try {
      const { imageUrl } = await generateProductImage({
        productName: product.name,
        sourceImageUrl: product.image,
      });

      if (imageUrl) {
        handleUpdateProduct(product.id, { image: imageUrl });
        toast({
          title: 'AI Image Generated!',
          description: `A new image for "${product.name}" has been generated.`,
        });
      } else {
        throw new Error('Image generation returned an empty URL.');
      }
    } catch (error) {
      console.error('Failed to generate image:', error);
      toast({
        variant: 'destructive',
        title: 'AI Image Failed',
        description: 'Could not generate a new image. Please try again.',
      });
    } finally {
      setGeneratingProductId(null);
    }
  };

  const handleSendToEbayDraft = async (product: Product) => {
    setGeneratingProductId(product.id);
    try {
      const res = await fetch('/api/ebay/drafts', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(product),
      });
      if (!res.ok) {
        throw new Error('Failed to create eBay draft');
      }
      toast({
        title: 'Sent to eBay',
        description: `"${product.name}" has been sent to eBay drafts.`,
      });
    } catch (error) {
      console.error('Failed to send to eBay', error);
      toast({
        variant: 'destructive',
        title: 'eBay Draft Failed',
        description: 'Could not send product to eBay drafts.',
      });
    } finally {
      setGeneratingProductId(null);
    }
  };

  const handlePublishToShopify = async (product: Product) => {
    setGeneratingProductId(product.id);
    try {
      const res = await fetch('/api/shopify/publish', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(product),
      });

      const result = await res.json();
      if (!res.ok) {
        throw new Error(result.error || 'Failed to publish to Shopify');
      }

      toast({
        title: 'Published to Shopify!',
        description: `"${product.name}" is now live on Shopify.`,
      });
    } catch (error: any) {
      console.error('Failed to publish to Shopify', error);
      toast({
        variant: 'destructive',
        title: 'Shopify Publish Failed',
        description: error.message,
      });
    } finally {
      setGeneratingProductId(null);
    }
  };

  const handleExportToCSV = () => {
    if (selectedIds.size > 0) {
       router.push('/exports');
    } else {
        toast({
            variant: 'destructive',
            title: 'Export Canceled',
            description: 'Please select at least one product to export.',
        });
    }
  };
  
  const handleErpAction = async (action: 'import' | 'update' | 'export') => {
    setIsErpLoading(true);
    const productsToExport = products.filter(p => selectedIds.has(p.id));

    try {
        if (action === 'export') {
            if (productsToExport.length === 0) {
                toast({
                    variant: 'destructive',
                    title: 'Export Canceled',
                    description: 'Please select at least one product to export to ERPNext.',
                });
                return;
            }
            await exportProductsToERPNext(
                (loading) => setIsErpLoading(loading),
                productsToExport
            );
            return; 
        }

        if (action === 'import') {
            let allItems: any[] = [];
            const pageSize = 100;
            let start = 0;
            let hasMore = true;

            while (hasMore) {
                const endpoint = `/api/resource/Item?fields=["name","item_code","item_name","standard_rate","image","description","modified"]&limit_page_length=${pageSize}&limit_start=${start}`;
                const response = await fetch('/api/proxy-erpnext', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ endpoint, method: 'GET' }),
                });

                if (!response.ok) {
                    const resultText = await response.text();
                    try {
                        const errorBody = JSON.parse(resultText);
                        throw new Error(errorBody.error || 'Import failed');
                    } catch (e) {
                        throw new Error(resultText || `Import failed with status ${response.status}`);
                    }
                }

                const result = await response.json();
                if (result.data && result.data.length > 0) {
                    allItems = allItems.concat(result.data);
                    start += pageSize;
                } else {
                    hasMore = false;
                }
            }

            if (allItems.length > 0) {
                const newProducts: Product[] = allItems.map((item: any) => ({
                    id: String(item.name),
                    name: String(item.item_name || item.name),
                    code: String(item.item_code),
                    price: Number(item.standard_rate || 0),
                    description: String(item.description || ''),
                    image: item.image ? `${process.env.NEXT_PUBLIC_ERPNEXT_BASE_URL || ''}${item.image}` : '',
                    quantity: 0,
                    listingStatus: asListingStatus(item.listingStatus),
                    category: String(item.category || ''),
                    ebayCategoryId: String(item.ebayCategoryId || ''),
                    tags: Array.isArray(item.tags) ? item.tags : [],
                    keywords: Array.isArray(item.keywords) ? item.keywords : [],
                    supplier: String(item.supplier || ''),
                    location: String(item.location || ''),
                    technicalSpecs: typeof item.technicalSpecs === "object" && item.technicalSpecs !== null ? item.technicalSpecs : {},
                    sourceModified: item.modified,
                    ean: item.barcode ? String(item.barcode) : undefined,
                }));
                setProducts(newProducts);
                 toast({
                    title: `ERP Import Successful!`,
                    description: `${newProducts.length} products have been imported.`,
                });
            } else {
                 toast({
                    title: 'No new products found',
                    description: 'Your product list is already up to date.',
                });
            }
        }
    } catch (error: any) {
        console.error(`ERP ${action} failed:`, error);
        toast({
            variant: 'destructive',
            title: `ERP ${action} Failed`,
            description: error.message,
        });
    } finally {
        setIsErpLoading(false);
    }
  };


  const columns = React.useMemo(() => getColumns({
      onEdit: handleEditProduct,
      onDelete: handleDeleteProduct,
      onGenerate: handleGenerateDescription,
      onCopyDescription: handleCopyDescription,
      onExtractTechSpecs: handleExtractTechSpecs,
      onGenerateImage: handleGenerateImage,
      onSendToEbay: handleSendToEbayDraft,
      onPublishToShopify: handlePublishToShopify,
      generatingProductId,
      onUpdateProduct: handleUpdateProduct,
  }), [generatingProductId, products]);

  if (isLoading) {
    return (
      <div className="flex items-center justify-center min-h-screen">
        <Loader2 className="h-16 w-16 animate-spin" />
      </div>
    );
  }

  return (
    <main className="grid flex-1 items-start gap-4 p-4 sm:px-6 sm:py-0 md:gap-8">
      {selectedProducts.length > 0 && (
        <SelectedProducts 
            products={selectedProducts}
            onEditProduct={handleEditProduct}
            onBulkEdit={() => setIsBulkEditDialogOpen(true)}
            onClear={clearSelection}
            onRemove={toggleSelection}
        />
      )}
      <Card>
        <CardHeader className="flex flex-row items-center">
          <div className="flex-1">
            <CardTitle>Products</CardTitle>
             <CardDescription>
              Manage your products. Use the buttons to sync with ERPNext.
            </CardDescription>
          </div>
          <div className="ml-auto flex items-center gap-2">
            
             <EnvBadge />

             {/* Desktop Buttons */}
            <div className="hidden md:flex items-center gap-2">
                 {isErpLoading ? (
                   <Button size="sm" variant="outline" className="h-8 gap-1" disabled>
                      <Loader2 className="h-3.5 w-3.5 animate-spin" />
                      <span>Syncing...</span>
                    </Button>
                ) : (
                    <div className="flex items-center gap-2">
                       <Button size="sm" variant="outline" className="h-8 gap-1" onClick={() => handleErpAction('import')}>
                          <Download className="h-3.5 w-3.5" />
                          <span>Import from ERPNext</span>
                        </Button>
                        <Button size="sm" variant="outline" className="h-8 gap-1" onClick={() => handleErpAction('update')} disabled>
                          <RefreshCw className="h-3.5 w-3.5" />
                          <span>Update from ERPNext</span>
                        </Button>
                        <Button size="sm" variant="outline" className="h-8 gap-1" onClick={() => handleErpAction('export')} disabled={selectedProductIds.length === 0}>
                          <Send className="h-3.5 w-3.5" />
                          <span>Export to ERPNext ({selectedProductIds.length})</span>
                        </Button>
                    </div>
                )}
                 <Button size="sm" variant="outline" className="h-8 gap-1" onClick={handleExportToCSV} disabled={selectedProductIds.length === 0}>
                  <File className="h-3.5 w-3.5" />
                  <span>Export CSV ({selectedProductIds.length})</span>
                </Button>
                 <Dialog open={isBulkEditDialogOpen} onOpenChange={setIsBulkEditDialogOpen}>
                  <DialogTrigger asChild>
                      <Button size="sm" variant="outline" className="h-8 gap-1" disabled={selectedProductIds.length === 0}>
                        <FilePenLine className="h-3.5 w-3.5" />
                        <span>Bulk Edit ({selectedProductIds.length})</span>
                      </Button>
                  </DialogTrigger>
                  <DialogContent className="sm:max-w-md">
                    <DialogHeader>
                        <DialogTitle>Bulk Edit {selectedProductIds.length} Products</DialogTitle>
                        <DialogDescription>
                            Modify the fields below to update all selected products at once. Leave a field blank to keep its current value.
                        </DialogDescription>
                    </DialogHeader>
                    <BulkEditForm 
                        onSave={handleSaveBulkEdit} 
                        onCancel={() => setIsBulkEditDialogOpen(false)}
                    />
                  </DialogContent>
                </Dialog>
            </div>
           
            <Sheet open={isSheetOpen} onOpenChange={setIsSheetOpen}>
              <SheetTrigger asChild>
                  <Button size="sm" className="h-8 gap-1" onClick={handleAddProduct}>
                  <PlusCircle className="h-3.5 w-3.5" />
                  <span className="sr-only sm:not-sr-only sm:whitespace-nowrap">
                    Add Product
                  </span>
                </Button>
              </SheetTrigger>
              <SheetContent className="sm:max-w-2xl" side="right">
                <SheetHeader>
                    <SheetTitle>{selectedProduct ? 'Edit Product' : 'Add New Product'}</SheetTitle>
                  <SheetDescription>
                    {selectedProduct
                      ? 'Update the details of your product.'
                      : 'Fill in the details for the new product.'}
                  </SheetDescription>
                </SheetHeader>
                <ProductForm 
                  product={selectedProduct} 
                  onSave={handleSaveProduct} 
                  onCancel={() => setIsSheetOpen(false)} 
                />
              </SheetContent>
            </Sheet>

            {/* Mobile Dropdown */}
            <div className="md:hidden">
                 <DropdownMenu>
                    <DropdownMenuTrigger asChild>
                        <Button size="icon" variant="outline" className="h-8 w-8">
                            <MoreVertical className="h-4 w-4" />
                            <span className="sr-only">More actions</span>
                        </Button>
                    </DropdownMenuTrigger>
                    <DropdownMenuContent align="end">
                         {isErpLoading ? (
                            <DropdownMenuItem disabled>
                                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                                <span>Syncing...</span>
                            </DropdownMenuItem>
                        ) : (
                            <>
                                <DropdownMenuItem onClick={() => handleErpAction('import')}>
                                    <Download className="mr-2 h-4 w-4" />
                                    <span>Import from ERPNext</span>
                                </DropdownMenuItem>
                                <DropdownMenuItem onClick={() => handleErpAction('update')} disabled>
                                    <RefreshCw className="mr-2 h-4 w-4" />
                                    <span>Update from ERPNext</span>
                                </DropdownMenuItem>
                                <DropdownMenuItem onClick={() => handleErpAction('export')} disabled={selectedProductIds.length === 0}>
                                    <Send className="mr-2 h-4 w-4" />
                                    <span>Export to ERPNext ({selectedProductIds.length})</span>
                                </DropdownMenuItem>
                            </>
                        )}
                        <DropdownMenuItem onClick={handleExportToCSV} disabled={selectedProductIds.length === 0}>
                            <File className="mr-2 h-4 w-4" />
                            <span>Export CSV ({selectedProductIds.length})</span>
                        </DropdownMenuItem>
                         <DropdownMenuItem onSelect={() => setIsBulkEditDialogOpen(true)} disabled={selectedProductIds.length === 0}>
                           <FilePenLine className="mr-2 h-4 w-4" />
                            <span>Bulk Edit ({selectedProductIds.length})</span>
                        </DropdownMenuItem>
                    </DropdownMenuContent>
                </DropdownMenu>
            </div>
          </div>
        </CardHeader>
        <CardContent>
          <ProductDataTable 
            columns={columns} 
            data={products} 
            onBulkDelete={handleBulkDelete}
          />
        </CardContent>
      </Card>
    </main>
  );
}

export default function Dashboard() {
    return <DashboardClient />;
}
