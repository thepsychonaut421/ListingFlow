// This file is generated by Firebase Studio
'use client';

import * as React from 'react';
import {
  File,
  PlusCircle,
  Upload,
  FilePenLine,
  Database,
  DollarSign,
  Download,
  RefreshCw,
  Send,
  Loader2,
  ImageIcon
} from 'lucide-react';
import Papa from 'papaparse';
import type { RowSelectionState } from '@tanstack/react-table';

import { Button } from '@/components/ui/button';
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from '@/components/ui/card';
import {
    Sheet,
    SheetContent,
    SheetHeader,
    SheetTitle,
    SheetDescription,
    SheetTrigger
} from '@/components/ui/sheet';
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogDescription,
  DialogTrigger,
} from '@/components/ui/dialog';
import type { Product } from '@/lib/types';
import { initialProducts } from '@/lib/data';
import { ProductDataTable } from '@/components/product-data-table';
import { getColumns } from '@/components/product-columns';
import { generateProductDescription } from '@/ai/flows/generate-product-description';
import { findProductDescription } from '@/ai/flows/find-product-description';
import { findTechnicalSpecs } from '@/ai/flows/find-technical-specs';
import { generateProductImage } from '@/ai/flows/generate-product-image';
import { useToast } from '@/hooks/use-toast';
import { ProductForm } from '@/components/product-form';
import { BulkEditForm } from '@/components/bulk-edit-form';
import {
  importProductsFromERPNext,
  updatePricesAndStocksFromERPNext,
  exportProductsToERPNext,
} from '@/lib/erpnext';


function DashboardClient() {
  const [products, setProducts] = React.useState<Product[]>([]);
  const [isSheetOpen, setIsSheetOpen] = React.useState(false);
  const [isBulkEditOpen, setIsBulkEditOpen] = React.useState(false);
  const [selectedProduct, setSelectedProduct] = React.useState<Product | null>(null);
  const [rowSelection, setRowSelection] = React.useState<RowSelectionState>({});
  const [isLoading, setIsLoading] = React.useState(true);
  const [isErpLoading, setIsErpLoading] = React.useState(false);
  const [generatingProductId, setGeneratingProductId] = React.useState<string | null>(null);
  const { toast } = useToast();
  const fileInputRef = React.useRef<HTMLInputElement>(null);
  const erpFileInputRef = React.useRef<HTMLInputElement>(null);
  const priceFileInputRef = React.useRef<HTMLInputElement>(null);

  const selectedProductIds = React.useMemo(() => Object.keys(rowSelection), [rowSelection]);
  

  React.useEffect(() => {
    try {
      const storedProducts = localStorage.getItem('listingFlowProducts');
      if (storedProducts) {
        setProducts(JSON.parse(storedProducts));
      } else {
        setProducts(initialProducts);
      }
    } catch (error) {
      console.error('Failed to parse products from localStorage', error);
      setProducts(initialProducts);
    }
    setIsLoading(false);
  }, []);

  React.useEffect(() => {
    if (!isLoading) {
      localStorage.setItem('listingFlowProducts', JSON.stringify(products));
    }
  }, [products, isLoading]);
  
  // Effect to store selected product IDs in localStorage for the exports page
  React.useEffect(() => {
    localStorage.setItem('listingFlowSelectedProductIds', JSON.stringify(selectedProductIds));
  }, [selectedProductIds]);

  const handleAddProduct = () => {
    setSelectedProduct(null);
    setIsSheetOpen(true);
  };

  const handleEditProduct = (product: Product) => {
    setSelectedProduct(product);
    setIsSheetOpen(true);
  };

  const handleDeleteProduct = (id: string) => {
    setProducts(products.filter((p) => p.id !== id));
  };
  
  const handleBulkDelete = (ids: string[]) => {
    setProducts(products.filter((p) => !ids.includes(p.id)));
    setRowSelection({}); // Clear selection after deletion
    toast({
        title: 'Products Deleted',
        description: `${ids.length} products have been deleted successfully.`,
    });
  };

  const handleSaveProduct = (productData: Product) => {
    if (selectedProduct) {
        setProducts(products.map((p) => (p.id === productData.id ? productData : p)));
    } else {
        setProducts([
            { ...productData, id: crypto.randomUUID() },
            ...products,
        ]);
    }
    setIsSheetOpen(false);
    setSelectedProduct(null);
  };
  
  const handleUpdateProduct = (id: string, data: Partial<Product>) => {
    setProducts(products.map(p => p.id === id ? { ...p, ...data } : p));
  };

  const handleSaveBulkEdit = (data: Partial<Product>) => {
    setProducts(products.map(p => {
        if (selectedProductIds.includes(p.id)) {
            const updatedProduct = { ...p };
            for (const key in data) {
                if (data[key as keyof typeof data]) {
                    (updatedProduct as any)[key] = data[key as keyof typeof data];
                }
            }
            return updatedProduct;
        }
        return p;
    }));
    toast({
        title: 'Bulk Edit Successful',
        description: `${selectedProductIds.length} products have been updated.`,
    });
    setIsBulkEditOpen(false);
    setRowSelection({}); // Clear selection
  };
  
  const handleGenerateDescription = async (product: Product) => {
    setGeneratingProductId(product.id);
    try {
      const result = await generateProductDescription({
        productName: product.name,
        category: product.category,
        listingStatus: product.listingStatus as 'new' | 'used' | 'refurbished',
        brand: product.brand,
      });
      
      setProducts(products.map(p => p.id === product.id ? {
        ...p,
        description: result.description,
        tags: Array.isArray(result.tags) ? result.tags : [],
        keywords: Array.isArray(result.keywords) ? result.keywords : [],
        category: result.category,
        ebayCategoryId: result.ebayCategoryId,
        brand: result.brand,
        productType: result.productType,
        ean: result.ean,
      } : p));

      toast({
        title: 'AI Magic Successful!',
        description: `Description for "${product.name}" has been generated.`,
      });

    } catch (error) {
      console.error('Failed to generate description:', error);
      toast({
        variant: 'destructive',
        title: 'AI Magic Failed',
        description: 'Could not generate a new description. Please try again.',
      });
    } finally {
      setGeneratingProductId(null);
    }
  };

  const handleCopyDescription = async (product: Product, source: 'otto' | 'ebay') => {
    setGeneratingProductId(product.id);
    try {
      const result = await findProductDescription({
        productName: product.name,
        brand: product.brand,
        ean: product.ean,
        source: source,
      });
      
      if (result.description || Object.keys(result.technicalSpecs).length > 0) {
        handleUpdateProduct(product.id, { 
          description: result.description,
          technicalSpecs: {
            ...product.technicalSpecs,
            ...result.technicalSpecs
          }
        });
        toast({
          title: 'Content Copied!',
          description: `Description and specs for "${product.name}" have been copied from ${source}.de.`,
        });
      } else {
        toast({
          variant: 'destructive',
          title: 'Copy Failed',
          description: `Could not find content for "${product.name}" on ${source}.de.`,
        });
      }

    } catch (error) {
      console.error(`Failed to copy description from ${source}:`, error);
      toast({
        variant: 'destructive',
        title: 'Copy Failed',
        description: `An error occurred while copying from ${source}.de.`,
      });
    } finally {
      setGeneratingProductId(null);
    }
  };

  const handleExtractTechSpecs = async (product: Product) => {
    setGeneratingProductId(product.id);
    try {
        const result = await findTechnicalSpecs({
            productName: product.name,
            description: product.description,
        });

        if (result.specs && Object.keys(result.specs).length > 0) {
            handleUpdateProduct(product.id, {
                technicalSpecs: {
                    ...product.technicalSpecs,
                    ...result.specs,
                },
            });
            toast({
                title: 'AI Extraction Successful',
                description: `Technical specs for "${product.name}" have been extracted.`,
            });
        } else {
            toast({
                variant: 'destructive',
                title: 'Extraction Failed',
                description: `Could not find any technical specs for "${product.name}".`,
            });
        }
    } catch (error) {
        console.error('Failed to extract tech specs:', error);
        toast({
            variant: 'destructive',
            title: 'AI Extraction Failed',
            description: 'An error occurred while extracting technical specs.',
        });
    } finally {
        setGeneratingProductId(null);
    }
  };
  
    const handleGenerateImage = async (product: Product) => {
    setGeneratingProductId(product.id);
    try {
      const { imageUrl } = await generateProductImage({
        productName: product.name,
        sourceImageUrl: product.image,
      });

      if (imageUrl) {
        handleUpdateProduct(product.id, { image: imageUrl });
        toast({
          title: 'AI Image Generated!',
          description: `A new image for "${product.name}" has been generated.`,
        });
      } else {
        throw new Error('Image generation returned an empty URL.');
      }
    } catch (error) {
      console.error('Failed to generate image:', error);
      toast({
        variant: 'destructive',
        title: 'AI Image Failed',
        description: 'Could not generate a new image. Please try again.',
      });
    } finally {
      setGeneratingProductId(null);
    }
  };

  const handleSendToEbayDraft = async (product: Product) => {
    setGeneratingProductId(product.id);
    try {
      const res = await fetch('/api/ebay/drafts', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(product),
      });
      if (!res.ok) {
        throw new Error('Failed to create eBay draft');
      }
      toast({
        title: 'Sent to eBay',
        description: `"${product.name}" has been sent to eBay drafts.`,
      });
    } catch (error) {
      console.error('Failed to send to eBay', error);
      toast({
        variant: 'destructive',
        title: 'eBay Draft Failed',
        description: 'Could not send product to eBay drafts.',
      });
    } finally {
      setGeneratingProductId(null);
    }
  };

  const handleExportToCSV = () => {
    const productsToExport = products.filter(p => selectedProductIds.includes(p.id));

    if (productsToExport.length === 0) {
      toast({
        variant: 'destructive',
        title: 'Export Failed',
        description: 'Please select at least one product to export.',
      });
      return;
    }

    const headers = [
      'id', 'name', 'code', 'quantity', 'price', 'description', 
      'image', 'supplier', 'location', 'tags', 'keywords', 'category', 'ebayCategoryId', 'listingStatus',
      'brand', 'productType', 'ean'
    ];
    const rows = productsToExport.map(product => 
      headers.map(header => {
        let value = product[header as keyof Product];
        
        if (header === 'technicalSpecs') {
            value = JSON.stringify(product.technicalSpecs);
        }

        if (Array.isArray(value)) {
          return `"${value.join(', ')}"`;
        }
        if (typeof value === 'string') {
          return `"${value.replace(/"/g, '""')}"`;
        }
        return value;
      }).join(',')
    );

    const csvContent = [headers.join(','), ...rows].join('\n');
    const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
    const link = document.createElement('a');
    const url = URL.createObjectURL(blob);
    link.setAttribute('href', url);
    link.setAttribute('download', `products-export-${new Date().toISOString()}.csv`);
    link.style.visibility = 'hidden';
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    
    toast({
        title: 'Export Successful',
        description: `Your ${productsToExport.length} selected products have been exported to CSV.`,
    });
  };

  const handleImportClick = () => {
    fileInputRef.current?.click();
  };
  
  const handleErpImportClick = () => {
    erpFileInputRef.current?.click();
  };
  
  const handlePriceImportClick = () => {
    priceFileInputRef.current?.click();
  };

  const handleCSVUpload = (event: React.ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files?.[0];
    if (!file) return;

    Papa.parse(file, {
      header: true,
      skipEmptyLines: true,
      complete: (results) => {
        try {
          const newProducts = results.data.map((row: any): Product => {
            const code = row['Artikel-Code'] || row['Cod articol'] || '';
            const name = row['Artikelname'] || row['Numele articolului'] || 'No Name';
            const category = row['Artikelgruppe'] || row['Grup Articol'] || '';
            
            return {
              id: crypto.randomUUID(),
              name: name,
              code: code.toString(),
              quantity: 0,
              price: 0,
              description: '',
              image: '',
              supplier: '',
              location: '',
              tags: [],
              keywords: [],
              category: category,
              ebayCategoryId: '',
              listingStatus: 'draft',
              brand: '',
              productType: '',
              ean: '',
              technicalSpecs: {},
            };
          }).filter(p => p.code); // Filter out any items without a SKU

          const updatedProducts = [...newProducts, ...products];
          setProducts(updatedProducts);

          toast({
            title: 'Import Successful',
            description: `${newProducts.length} products have been imported and added to the list.`,
          });
        } catch (err) {
          console.error("Error processing CSV data:", err);
          toast({
            variant: 'destructive',
            title: 'Import Failed',
            description: 'Could not process the CSV file. Please check the file format.',
          });
        }
      },
      error: (err) => {
        console.error("Error parsing CSV:", err);
        toast({
            variant: 'destructive',
            title: 'Import Failed',
            description: 'Could not parse the CSV file. Please ensure it is a valid CSV.',
        });
      },
    });
    
    if(event.target) {
        event.target.value = '';
    }
  };

  const handlePriceCSVUpload = (event: React.ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files?.[0];
    if (!file) return;

    Papa.parse(file, {
      header: true,
      skipEmptyLines: true,
      complete: (results) => {
        let updatedCount = 0;
        let notFoundCount = 0;
        
        const priceMap = new Map<string, number>();
        results.data.forEach((row: any) => {
          const sku = row['Cod articol'] || row['Artikel-Code'];
          const price = row['Pret'] || row['Preis'];
          if (sku && price !== undefined) {
             const parsedPrice = parseFloat(String(price).replace(',', '.'));
             if (!isNaN(parsedPrice)) {
                priceMap.set(String(sku).trim(), parsedPrice);
             }
          }
        });
        
        if(priceMap.size === 0) {
            toast({
              variant: 'destructive',
              title: 'Update Failed',
              description: 'No valid price data found in the CSV. Check column headers (e.g., "Cod articol", "Pret").',
            });
            return;
        }

        setProducts(currentProducts => {
            const updatedProducts = currentProducts.map(p => {
                if (priceMap.has(p.code)) {
                    updatedCount++;
                    return { ...p, price: priceMap.get(p.code)! };
                }
                return p;
            });

            const productsInFile = Array.from(priceMap.keys());
            const productsInTable = currentProducts.map(p => p.code);
            notFoundCount = productsInFile.filter(code => !productsInTable.includes(code)).length;

            toast({
              title: 'Price Update Complete',
              description: `${updatedCount} prices updated. ${notFoundCount} SKUs from the file were not found in the table.`,
            });
            return updatedProducts;
        });

      },
      error: (err) => {
        console.error("Error parsing Price CSV:", err);
        toast({
            variant: 'destructive',
            title: 'Import Failed',
            description: 'Could not parse the price CSV file.',
        });
      },
    });

    if(event.target) {
        event.target.value = '';
    }
  };
  
    const handleErpImport = async () => {
    await importProductsFromERPNext(setIsErpLoading, setProducts, products);
  };

  const handleErpUpdate = async () => {
    await updatePricesAndStocksFromERPNext(setIsErpLoading, setProducts, products);
  };

  const handleErpExport = async () => {
    if (selectedProductIds.length === 0) {
      toast({
        variant: 'destructive',
        title: 'Export Failed',
        description: 'Please select at least one product to export.',
      });
      return;
    }
    const productsToExport = products.filter(p => selectedProductIds.includes(p.id));
    await exportProductsToERPNext(setIsErpLoading, productsToExport);
  };


  const columns = React.useMemo(() => getColumns({
      onEdit: handleEditProduct,
      onDelete: handleDeleteProduct,
      onGenerate: handleGenerateDescription,
      onUpdate: handleUpdateProduct,
      onCopyDescription: handleCopyDescription,
      onExtractTechSpecs: handleExtractTechSpecs,
      onGenerateImage: handleGenerateImage,
      onSendToEbay: handleSendToEbayDraft,
      generatingProductId,
  }), [generatingProductId, products]);

  if (isLoading) {
    return (
      <div className="flex items-center justify-center min-h-screen">
        <div className="text-2xl">Loading Products...</div>
      </div>
    );
  }

  return (
    <main className="grid flex-1 items-start gap-4 p-4 sm:px-6 sm:py-0 md:gap-8">
      <Card>
        <CardHeader className="flex flex-row items-center">
          <div>
            <CardTitle>Products</CardTitle>
             <CardDescription>
              Manage your products. Use the buttons to sync with ERPNext.
            </CardDescription>
          </div>
          <div className="ml-auto flex items-center gap-2">
            
            {isErpLoading ? (
               <Button size="sm" variant="outline" className="h-8 gap-1" disabled>
                  <Loader2 className="h-3.5 w-3.5 animate-spin" />
                  <span className="sr-only sm:not-sr-only sm:whitespace-nowrap">
                    Syncing...
                  </span>
                </Button>
            ) : (
                <div className="flex items-center gap-2">
                   <Button size="sm" variant="outline" className="h-8 gap-1" onClick={handleErpImport}>
                      <Download className="h-3.5 w-3.5" />
                      <span className="sr-only sm:not-sr-only sm:whitespace-nowrap">
                        Import from ERPNext
                      </span>
                    </Button>
                    <Button size="sm" variant="outline" className="h-8 gap-1" onClick={handleErpUpdate}>
                      <RefreshCw className="h-3.5 w-3.5" />
                      <span className="sr-only sm:not-sr-only sm:whitespace-nowrap">
                        Update from ERPNext
                      </span>
                    </Button>
                    <Button size="sm" variant="outline" className="h-8 gap-1" onClick={handleErpExport} disabled={selectedProductIds.length === 0}>
                      <Send className="h-3.5 w-3.5" />
                      <span className="sr-only sm:not-sr-only sm:whitespace-nowrap">
                        Export to ERPNext ({selectedProductIds.length})
                      </span>
                    </Button>
                </div>
            )}
            <Button size="sm" variant="outline" className="h-8 gap-1" onClick={handleExportToCSV} disabled={selectedProductIds.length === 0}>
              <File className="h-3.5 w-3.5" />
              <span className="sr-only sm:not-sr-only sm:whitespace-nowrap">
                Export CSV ({selectedProductIds.length})
              </span>
            </Button>
             <Dialog open={isBulkEditOpen} onOpenChange={setIsBulkEditOpen}>
              <DialogTrigger asChild>
                  <Button size="sm" variant="outline" className="h-8 gap-1" disabled={selectedProductIds.length === 0}>
                    <FilePenLine className="h-3.5 w-3.5" />
                    <span className="sr-only sm:not-sr-only sm:whitespace-nowrap">
                        Bulk Edit ({selectedProductIds.length})
                    </span>
                  </Button>
              </DialogTrigger>
              <DialogContent className="sm:max-w-md">
                <DialogHeader>
                    <DialogTitle>Bulk Edit Products</DialogTitle>
                    <DialogDescription>
                        Modify the fields below to update all {selectedProductIds.length} selected products at once.
                    </DialogDescription>
                </DialogHeader>
                <BulkEditForm 
                    onSave={handleSaveBulkEdit} 
                    onCancel={() => setIsBulkEditOpen(false)}
                />
              </DialogContent>
            </Dialog>
            <Sheet open={isSheetOpen} onOpenChange={setIsSheetOpen}>
              <SheetTrigger asChild>
                  <Button size="sm" className="h-8 gap-1" onClick={handleAddProduct}>
                  <PlusCircle className="h-3.5 w-3.5" />
                  <span className="sr-only sm:not-sr-only sm:whitespace-nowrap">
                    Add Product
                  </span>
                </Button>
              </SheetTrigger>
              <SheetContent className="sm:max-w-2xl" side="right">
                <SheetHeader>
                    <SheetTitle>{selectedProduct ? 'Edit Product' : 'Add New Product'}</SheetTitle>
                  <SheetDescription>
                    {selectedProduct
                      ? 'Update the details of your product.'
                      : 'Fill in the details for the new product.'}
                  </SheetDescription>
                </SheetHeader>
                <ProductForm 
                  product={selectedProduct} 
                  onSave={handleSaveProduct} 
                  onCancel={() => setIsSheetOpen(false)} 
                />
              </SheetContent>
            </Sheet>
          </div>
        </CardHeader>
        <CardContent>
          <ProductDataTable 
            columns={columns} 
            data={products} 
            onBulkDelete={handleBulkDelete}
            rowSelection={rowSelection}
            setRowSelection={setRowSelection}
          />
        </CardContent>
      </Card>
    </main>
  );
}

export default function Dashboard() {
    return <DashboardClient />;
}
