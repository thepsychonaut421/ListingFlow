// This file is generated by Firebase Studio
'use client';

import * as React from 'react';
import {
  File,
  PlusCircle,
  Upload,
} from 'lucide-react';
import Papa from 'papaparse';

import { Button } from '@/components/ui/button';
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from '@/components/ui/card';
import {
    Sheet,
    SheetContent,
    SheetHeader,
    SheetTitle,
    SheetDescription,
    SheetTrigger
} from '@/components/ui/sheet';
import type { Product } from '@/lib/types';
import { initialProducts } from '@/lib/data';
import { ProductDataTable } from '@/components/product-data-table';
import { getColumns } from '@/components/product-columns';
import { generateProductDescription } from '@/ai/flows/generate-product-description';
import { useToast } from '@/hooks/use-toast';
import { ProductForm } from '@/components/product-form';

export default function Dashboard() {
  const [products, setProducts] = React.useState<Product[]>([]);
  const [isSheetOpen, setIsSheetOpen] = React.useState(false);
  const [selectedProduct, setSelectedProduct] = React.useState<Product | null>(null);
  const [isLoading, setIsLoading] = React.useState(true);
  const [generatingProductId, setGeneratingProductId] = React.useState<string | null>(null);
  const { toast } = useToast();
  const fileInputRef = React.useRef<HTMLInputElement>(null);

  React.useEffect(() => {
    try {
      const storedProducts = localStorage.getItem('listingFlowProducts');
      if (storedProducts) {
        setProducts(JSON.parse(storedProducts));
      } else {
        setProducts(initialProducts);
      }
    } catch (error) {
      console.error('Failed to parse products from localStorage', error);
      setProducts(initialProducts);
    }
    setIsLoading(false);
  }, []);

  React.useEffect(() => {
    if (!isLoading) {
      localStorage.setItem('listingFlowProducts', JSON.stringify(products));
    }
  }, [products, isLoading]);

  const handleAddProduct = () => {
    setSelectedProduct(null);
    setIsSheetOpen(true);
  };

  const handleEditProduct = (product: Product) => {
    setSelectedProduct(product);
    setIsSheetOpen(true);
  };

  const handleDeleteProduct = (id: string) => {
    setProducts(products.filter((p) => p.id !== id));
  };

  const handleSaveProduct = (productData: Product) => {
    if (selectedProduct) {
        setProducts(products.map((p) => (p.id === productData.id ? productData : p)));
    } else {
        setProducts([
            { ...productData, id: crypto.randomUUID() },
            ...products,
        ]);
    }
    setIsSheetOpen(false);
    setSelectedProduct(null);
  };
  
  const handleGenerateDescription = async (product: Product) => {
    setGeneratingProductId(product.id);
    try {
      const result = await generateProductDescription({
        productName: product.name,
        category: product.category,
        listingStatus: product.listingStatus as 'new' | 'used' | 'refurbished',
        brand: product.brand,
      });
      
      setProducts(products.map(p => p.id === product.id ? {
        ...p,
        description: result.description,
        tags: Array.isArray(result.tags) ? result.tags : [],
        keywords: Array.isArray(result.keywords) ? result.keywords : [],
        category: result.category,
        ebayCategoryId: result.ebayCategoryId,
        brand: result.brand,
        productType: result.productType,
        ean: result.ean,
      } : p));

      toast({
        title: 'AI Magic Successful!',
        description: `Description for "${product.name}" has been generated.`,
      });

    } catch (error) {
      console.error('Failed to generate description:', error);
      toast({
        variant: 'destructive',
        title: 'AI Magic Failed',
        description: 'Could not generate a new description. Please try again.',
      });
    } finally {
      setGeneratingProductId(null);
    }
  };

  const handleExportToCSV = () => {
    const headers = [
      'id', 'name', 'code', 'quantity', 'price', 'description', 
      'image', 'supplier', 'location', 'tags', 'keywords', 'category', 'ebayCategoryId', 'listingStatus'
    ];
    const rows = products.map(product => 
      headers.map(header => {
        const value = product[header as keyof Product];
        if (Array.isArray(value)) {
          return `"${value.join(', ')}"`;
        }
        if (typeof value === 'string') {
          return `"${value.replace(/"/g, '""')}"`;
        }
        return value;
      }).join(',')
    );

    const csvContent = [headers.join(','), ...rows].join('\n');
    const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
    const link = document.createElement('a');
    const url = URL.createObjectURL(blob);
    link.setAttribute('href', url);
    link.setAttribute('download', `products-export-${new Date().toISOString()}.csv`);
    link.style.visibility = 'hidden';
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    
    toast({
        title: 'Export Successful',
        description: 'Your products have been exported to CSV.',
    });
  };

  const handleImportClick = () => {
    fileInputRef.current?.click();
  };

  const handleCSVUpload = (event: React.ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files?.[0];
    if (!file) return;

    Papa.parse(file, {
      header: true,
      skipEmptyLines: true,
      complete: (results) => {
        try {
          const newProducts = results.data.map((row: any): Product => {
            const price = parseFloat(row['Price List Rate']) || 0;
            return {
              id: crypto.randomUUID(),
              name: row['Item Name'] || 'No Name',
              code: row['Item Code']?.toString() || '',
              quantity: parseInt(row['Stock Qty'], 10) || 0,
              price: price,
              description: row['Description'] || '',
              image: '',
              supplier: '',
              location: '',
              tags: [],
              keywords: [],
              category: row['Item Group'] || '',
              ebayCategoryId: '',
              listingStatus: 'draft',
              brand: row['Brand'] || '',
              productType: '',
              ean: '',
            };
          }).filter(p => p.code); // Filter out any items without a SKU

          const updatedProducts = [...newProducts, ...products];
          setProducts(updatedProducts);

          toast({
            title: 'Import Successful',
            description: `${newProducts.length} products have been imported and added to the list.`,
          });
        } catch (err) {
          console.error("Error processing CSV data:", err);
          toast({
            variant: 'destructive',
            title: 'Import Failed',
            description: 'Could not process the CSV file. Please check the file format.',
          });
        }
      },
      error: (err) => {
        console.error("Error parsing CSV:", err);
        toast({
            variant: 'destructive',
            title: 'Import Failed',
            description: 'Could not parse the CSV file. Please ensure it is a valid CSV.',
        });
      },
    });
    
    // Reset file input
    if(event.target) {
        event.target.value = '';
    }
  };


  const columns = React.useMemo(() => getColumns({
      onEdit: handleEditProduct,
      onDelete: handleDeleteProduct,
      onGenerate: handleGenerateDescription,
      generatingProductId,
  }), [generatingProductId, products]);

  if (isLoading) {
    return (
      <div className="flex items-center justify-center min-h-screen">
        <div className="text-2xl">Loading Products...</div>
      </div>
    );
  }

  return (
    <main className="grid flex-1 items-start gap-4 p-4 sm:px-6 sm:py-0 md:gap-8">
      <Card>
        <CardHeader className="flex flex-row items-center">
          <div>
            <CardTitle>Products</CardTitle>
            <CardDescription>
              Manage your products and their listing details.
            </CardDescription>
          </div>
          <div className="ml-auto flex items-center gap-2">
            <input
              type="file"
              ref={fileInputRef}
              onChange={handleCSVUpload}
              accept=".csv"
              className="hidden"
            />
            <Button size="sm" variant="outline" className="h-8 gap-1" onClick={handleImportClick}>
              <Upload className="h-3.5 w-3.5" />
              <span className="sr-only sm:not-sr-only sm:whitespace-nowrap">
                Import
              </span>
            </Button>
            <Button size="sm" variant="outline" className="h-8 gap-1" onClick={handleExportToCSV}>
              <File className="h-3.5 w-3.5" />
              <span className="sr-only sm:not-sr-only sm:whitespace-nowrap">
                Export
              </span>
            </Button>
            <Sheet open={isSheetOpen} onOpenChange={setIsSheetOpen}>
              <SheetTrigger asChild>
                  <Button size="sm" className="h-8 gap-1" onClick={handleAddProduct}>
                  <PlusCircle className="h-3.5 w-3.5" />
                  <span className="sr-only sm:not-sr-only sm:whitespace-rap">
                    Add Product
                  </span>
                </Button>
              </SheetTrigger>
              <SheetContent className="sm:max-w-2xl" side="right">
                <SheetHeader>
                    <SheetTitle>{selectedProduct ? 'Edit Product' : 'Add New Product'}</SheetTitle>
                  <SheetDescription>
                    {selectedProduct
                      ? 'Update the details of your product.'
                      : 'Fill in the details for the new product.'}
                  </SheetDescription>
                </SheetHeader>
                <ProductForm 
                  product={selectedProduct} 
                  onSave={handleSaveProduct} 
                  onCancel={() => setIsSheetOpen(false)} 
                />
              </SheetContent>
            </Sheet>
          </div>
        </CardHeader>
        <CardContent>
          <ProductDataTable columns={columns} data={products} />
        </CardContent>
      </Card>
    </main>
  );
}
