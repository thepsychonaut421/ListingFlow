// This file is generated by Firebase Studio
import { NextResponse } from 'next/server';
import type { Product } from '@/lib/types';
import * as cheerio from 'cheerio';

/**
 * A generic fetch wrapper for making API calls to the ERPNext.
 * This should only be used in server-side routes.
 * @param endpoint The ERPNext API endpoint (e.g., /api/resource/Item).
 * @param init The standard RequestInit object for fetch (method, body, etc.).
 * @returns The JSON response from the API.
 * @throws An error if the request fails or returns a non-ok status.
 */
async function erpApiFetch(endpoint: string, init?: RequestInit) {
    const url = process.env.ERPNEXT_BASE_URL;
    const apiKey = process.env.ERPNEXT_API_KEY;
    const apiSecret = process.env.ERPNEXT_API_SECRET;
    
    if (!url || !apiKey || !apiSecret) {
        throw new Error('ERPNext credentials are not configured on the server.');
    }

    const fullUrl = `${url.replace(/\/$/, '')}${endpoint}`;
    const headers: Record<string, string> = {
      'Authorization': `token ${apiKey}:${apiSecret}`,
      'Content-Type': 'application/json',
      'Accept': 'application/json',
    };

    const requestOptions: RequestInit = {
      ...init,
      headers,
      cache: 'no-store',
    };
    
    const response = await fetch(fullUrl, requestOptions);

    if (!response.ok) {
        let errorDetails = `Request to ERPNext failed with status ${response.status}`;
        try {
            const errorText = await response.text();
            if (errorText.includes("frappe.exceptions.AuthenticationError")) {
                errorDetails = "Authentication Error. Please check your ERPNext API Key and Secret.";
            } else {
                 try {
                    const errorBody = JSON.parse(errorText);
                    errorDetails = errorBody.exception || errorBody.message || errorBody._server_messages || errorText;
                } catch(e) {
                    errorDetails = errorText;
                }
            }
        } catch (e: any) {
            errorDetails = `Failed to parse error response. Status: ${response.status}`;
        }
        throw new Error(errorDetails);
    }

    if (response.status === 204) {
      return null;
    }

    return response.json();
}


/**
 * Builds a comprehensive description string from product data.
 * @param product The product object.
 * @returns A formatted string ready to be used as a description.
 */
const buildFullDescription = (product: Product): string => {
  let fullDescription = product.description || '';
  const specs = { ...product.technicalSpecs };
  const brand = specs.Marke || specs.brand;
  const productType = specs['Produktart'];
  
  const mainSpecs: Record<string, any> = {};
  if (brand) mainSpecs['Marke'] = brand;
  if (productType) mainSpecs['Produktart'] = productType;
  
  const allSpecs = { ...mainSpecs, ...specs };

  const specEntries = Object.entries(allSpecs)
    .map(([key, value]) => {
      if (!value || ['brand', 'Marke', 'Produktart'].includes(key)) return null;
      const formattedValue = Array.isArray(value) ? value.join(', ') : value;
      const formattedKey = key.charAt(0).toUpperCase() + key.slice(1);
      return `${formattedKey}: ${formattedValue}`;
    })
    .filter(Boolean);

  if (specEntries.length > 0) {
    fullDescription += '\n\n<hr>\n\n<h3>Technische Daten:</h3>\n<ul>\n' + 
                       specEntries.map(entry => `  <li>${entry}</li>`).join('\n') + 
                       '\n</ul>';
  }

  return fullDescription.trim();
};


export async function POST(req: Request) {
  try {
    const { productsToExport } = (await req.json()) as { productsToExport: Product[] };

    if (!productsToExport || productsToExport.length === 0) {
      return NextResponse.json({ error: 'No products provided for export.' }, { status: 400 });
    }

    let successCount = 0;
    const errorMessages: string[] = [];

    // Preflight check
    await erpApiFetch(`/api/method/frappe.auth.get_logged_user`);

    for (const p of productsToExport) {
        const fullDescription = buildFullDescription(p);
        const brand = (p.technicalSpecs?.Marke || p.technicalSpecs?.brand || '') as string;
        
        const itemPayload: Record<string, any> = {
            item_code: p.code,
            item_name: p.name,
            standard_rate: p.price,
            description: fullDescription,
            web_long_description: fullDescription,
        };

        if(brand) itemPayload.brand = brand;

        try {
            await erpApiFetch(`/api/resource/Item/${p.code}`, { method: 'PUT', body: JSON.stringify(itemPayload) });
            successCount++;
        } catch (error: any) {
             const message = `Failed to export product ${p.code}: ${error.message}`;
             console.error(message);
             errorMessages.push(message);
        }
    }

    if (errorMessages.length > 0) {
      return NextResponse.json({ 
        message: `Export partially complete. Successfully updated ${successCount}/${productsToExport.length} products.`,
        errors: errorMessages 
      }, { status: 207 });
    }

    return NextResponse.json({ message: `Successfully updated ${successCount} products in ERPNext.` });

  } catch (error: any) {
    console.error('ERPNext export API route failed:', error);
    return NextResponse.json({ error: error.message || 'Failed to export to ERPNext' }, { status: 500 });
  }
}
