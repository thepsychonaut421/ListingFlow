// This file is generated by Firebase Studio.
'use server';
/**
 * @fileOverview An AI agent for finding eBay category IDs.
 *
 * It first attempts a fast, local search on a pre-defined JSON knowledge base.
 * If no confident match is found locally, it falls back to a generative AI model
 * for a more robust semantic search.
 *
 * - findEbayCategoryId - A function that finds the best eBay category ID for a product.
 * - FindEbayCategoryIdInput - The input type for the findEbayCategoryId function.
 * - FindEbayCategoryIdOutput - The return type for the findEbayCategoryId function.
 */

import { ai } from '@/ai/genkit';
import { z } from 'zod';
import path from 'path';
import fs from 'fs/promises';

// Define input and output schemas
const FindEbayCategoryIdInputSchema = z.object({
  productTitle: z.string().describe('The title of the product.'),
  ean: z.string().optional().describe('The EAN/UPC of the product, if available.'),
});
export type FindEbayCategoryIdInput = z.infer<typeof FindEbayCategoryIdInputSchema>;

const FindEbayCategoryIdOutputSchema = z.object({
  categoryId: z.string().describe('The suggested eBay category ID. Should be a numerical string.'),
  categoryPath: z.string().describe('The full path of the suggested category (e.g., "Home & Garden > Kitchen > Cookware").'),
  reason: z.enum(['local-search', 'ai-fallback', 'ean-direct-hit', 'none']).describe('The method used to find the category.'),
});
export type FindEbayCategoryIdOutput = z.infer<typeof FindEbayCategoryIdOutputSchema>;

// Local Knowledge Base Types
type CategoryRecord = { id: string; path: string; keywords?: string[]; name?: string };
type EanMap = Record<string, string>;

// --- Local Search Logic ---

/**
 * Loads a JSON file from the filesystem.
 * @param filename The name of the file to load from the 'public/data' directory.
 * @returns The parsed JSON data.
 */
async function loadLocalData<T>(filename: string): Promise<T | null> {
  try {
    const jsonPath = path.join(process.cwd(), 'public', 'data', filename);
    const fileContents = await fs.readFile(jsonPath, 'utf8');
    return JSON.parse(fileContents);
  } catch (error) {
    console.warn(`Could not load local data file "${filename}":`, error);
    return null;
  }
}

/**
 * Calculates a relevance score for a category based on a search query.
 * @param cat The category record.
 * @param query The search query.
 * @returns A numerical score.
 */
function calculateScore(cat: CategoryRecord, query: string): number {
    const q = query.toLowerCase().trim();
    if (!q) return 0;

    let score = 0;
    const path = (cat.path || "").toLowerCase();
    const name = (cat.name || "").toLowerCase();
    const keywords = (cat.keywords || []).map(k => k.toLowerCase());
    const queryWords = q.split(/\s+/).filter(w => w.length > 2);

    // High score for matching keywords
    for (const keyword of keywords) {
        if (q.includes(keyword)) score += 10;
    }
    
    // Score for words from query appearing in path or name
    for (const word of queryWords) {
        if (path.includes(word)) score += 2;
        if (name.includes(word)) score += 3; // Higher weight for name match
    }

    // Bonus for exact name match in path
    if (name && path.includes(name)) score += 5;
    
    return score;
}


/**
 * Performs a search on the local knowledge base.
 * @param productTitle The title to search for.
 * @returns The best matching category or null.
 */
async function localCategorySearch(productTitle: string): Promise<CategoryRecord | null> {
  const db = await loadLocalData<{ categories: CategoryRecord[] }>('ebay-categories.de.json');
  if (!db || !db.categories) return null;

  const ranked = db.categories
    .map(c => ({ ...c, _score: calculateScore(c, productTitle) }))
    .filter(c => c._score > 5) // Set a minimum threshold to avoid poor matches
    .sort((a, b) => b._score - a._score);

  return ranked.length > 0 ? ranked[0] : null;
}

// --- AI Fallback Logic ---
const aiPrompt = ai.definePrompt({
    name: 'ebayCategoryFinderPrompt',
    input: { schema: FindEbayCategoryIdInputSchema },
    output: { schema: z.object({ categoryId: z.string(), categoryPath: z.string() }) },
    prompt: `You are an eBay expert. Your task is to find the most specific and appropriate "leaf" category ID for a product.
    
    Analyze the product title and EAN. Return a single, valid, numerical eBay Germany (DE) category ID and its full path.
    
    Product Title: {{{productTitle}}}
    EAN: {{{ean}}}
    
    Output only a single JSON object with the keys "categoryId" and "categoryPath".
    `,
});

// --- Main Exported Flow ---

export async function findEbayCategoryId(input: FindEbayCategoryIdInput): Promise<FindEbayCategoryIdOutput> {
  return findEbayCategoryIdFlow(input);
}

const findEbayCategoryIdFlow = ai.defineFlow(
  {
    name: 'findEbayCategoryIdFlow',
    inputSchema: FindEbayCategoryIdInputSchema,
    outputSchema: FindEbayCategoryIdOutputSchema,
  },
  async ({ productTitle, ean }) => {
    // 1. Direct EAN lookup (highest priority)
    if (ean) {
        const eanMap = await loadLocalData<EanMap>('ean-to-category.json');
        const categoryId = eanMap?.[ean];
        if (categoryId) {
            const db = await loadLocalData<{ categories: CategoryRecord[] }>('ebay-categories.de.json');
            const categoryPath = db?.categories.find(c => c.id === categoryId)?.path || "Unknown Path";
            return { categoryId, categoryPath, reason: 'ean-direct-hit' };
        }
    }

    // 2. Local knowledge base search
    const localResult = await localCategorySearch(productTitle);
    if (localResult) {
      return {
        categoryId: localResult.id,
        categoryPath: localResult.path,
        reason: 'local-search',
      };
    }

    // 3. AI Fallback
    console.log(`Local search failed for "${productTitle}", falling back to AI.`);
    const { output } = await aiPrompt({ productTitle, ean });
    if (output) {
      return {
        categoryId: output.categoryId,
        categoryPath: output.categoryPath,
        reason: 'ai-fallback',
      };
    }

    // 4. No result found
    return {
      categoryId: '',
      categoryPath: '',
      reason: 'none',
    };
  }
);
