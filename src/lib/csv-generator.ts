
// This file is generated by Firebase Studio

import type { Product } from './types';

type Platform = 'ebay' | 'shopify';
type ProductTypeMap = Record<string, string[]>;

// --- Constants ---
const EOL = '\n';
const UTF8_BOM = '\uFEFF';
const SHOPIFY_PLACEHOLDER_IMAGE = 'https://placehold.co/600x600.png';

// --- Caching for JSON data ---
let _ptm: ProductTypeMap | null = null;
async function loadProductTypeMap(): Promise<ProductTypeMap> {
  if (_ptm) return _ptm;
  // This fetch path works because this code will be called from a client component
  // which then calls an API route where this function runs on the server.
  // In a pure server environment, you'd use fs.readFile.
  // For this setup, we assume it's called in a context that can fetch from /public
  try {
     const res = await fetch(`${process.env.NEXT_PUBLIC_BASE_URL || ''}/data/ebay-product-type-map.de.json`, { cache: 'no-store' });
    _ptm = res.ok ? await res.json() : {};
  } catch(e) {
    console.error("Failed to load product type map, returning empty.", e);
    _ptm = {};
  }
  return _ptm!;
}


// --- Helper Functions ---
const cleanSemicolonCsvField = (field: any): string => {
    if (field === null || field === undefined) return '';
    const cleaned = String(field).replace(/[\t\r\n;]/g, ' ').trim();
    return cleaned;
};


const escapeCommaCsvField = (field: any): string => {
  if (field === null || field === undefined) return '';
  const stringField = String(field).trim();
  if (/[,"\n\r]/.test(stringField)) {
    return `"${stringField.replace(/"/g, '""')}"`;
  }
  return stringField;
};

const buildCsvBody = (headers: string[], dataRows: string[][], delimiter: string): string => {
  const headerRow = headers.join(delimiter);
  const contentRows = dataRows.map(row => row.join(delimiter));
  return [headerRow, ...contentRows].join(EOL);
};

const safeTitle = (title?: string): string => {
    return (title || '').slice(0, 80).trim();
}

const safeImage = (url?: string): string => {
    if (url && (url.startsWith('http://') || url.startsWith('https://'))) {
        return url;
    }
    return ''; // Return empty string if invalid, eBay handles missing images.
}


// --- eBay Specific Logic ---

const getEbayConditionId = (status: Product['listingStatus']): number => {
  switch (status) {
    case 'new': return 1000;
    case 'used': return 3000;
    case 'refurbished': return 2500;
    default: return 1000; // Default to 'New' if status is draft/error etc.
  }
};


const pickVal = (
  product: Product,
  specs: Record<string, any>,
  ...keys: string[]
): string => {
   // Build a lowercase view of specs once for efficient, safe case-insensitive lookup.
  const specsLower = Object.fromEntries(
    Object.entries(specs).map(([kk, vv]) => [kk.toLowerCase(), vv])
  );

  for (const k of keys) {
    const keyLower = k.toLowerCase();
    const v =
      specs[k] ??                      // 1. Exact key on specs
      (product as any)[k] ??           // 2. Exact key on product
      specsLower[keyLower] ??          // 3. Case-insensitive key on specs
      (product as any)[keyLower];      // 4. Case-insensitive key on product
      
    if (v !== undefined && v !== null && String(v).trim() !== '') {
      return Array.isArray(v) ? v.join(', ') : String(v).trim();
    }
  }
  return '';
};


const inferProductType = (title: string, categoryId?: string): string => {
  const t = title.toLowerCase();
  if (categoryId === '36029' || /polo.?hemd|polo.?shirt/.test(t)) return 'Polohemd';
  if (/heissluftfrit+euse|air\s*fryer/.test(t)) return 'Heißluftfritteuse';
  if (/inlineskates|inline skates/.test(t)) return 'Inlineskates';
  if (/lautsprecher|speaker/.test(t)) return 'Lautsprecher';
  if (/teppich|rug/.test(t)) return 'Teppich';
  if (/topf(set)?|kochgeschirr|pfanne/.test(t)) return 'Kochgeschirr';
  if (/koch(en)?maschine|küchenmaschine/.test(t)) return 'Küchenmaschine';
  if (/staubsauger|vacuum/.test(t)) return 'Staubsauger';
  return '';
};

const PRODUCT_TYPE_MAP: Record<string, string> = {
  '11700': 'Teppich', // Teppiche & Teppichböden
  '20663': 'Küchenmaschine',
  '14969': 'Lautsprecher',
  '159912': 'Inlineskates',
  '20635': 'Kochgeschirr',
  '20643': 'Staubsauger',
  '43560': 'Pfannenset',
  '20649': 'Topfset',
  // ... can be extended as more categories are used
};

const resolveProductType = (product: Product): string => {
  const specs = product.technicalSpecs || {};
  // 1. Use explicitly defined product type first
  const explicitType = pickVal(product, specs, 'Produktart', 'productType', 'Type');
  if (explicitType) return explicitType;

  // 2. If a category ID is present, use the map
  if (product.ebayCategoryId && PRODUCT_TYPE_MAP[product.ebayCategoryId]) {
    return PRODUCT_TYPE_MAP[product.ebayCategoryId];
  }
  
  // 3. Fallback to inferring from title
  return inferProductType(product.name, product.ebayCategoryId);
};


const generateEbayCsvContent = async (products: Product[]): Promise<string> => {
  const headers = [
    'Action(SiteID=Germany|Country=DE|Currency=EUR|Version=1193|CC=UTF-8)',
    'Custom label (SKU)', 'Category ID', 'Title', 'UPC', 'Price', 'Quantity',
    'Item photo URL', 'Condition ID', 'Description', 'Format', 'C:Marke', 'C:Produktart',
    'C:Modell', 'C:Herstellernummer' // MPN
  ];

  const dataRowsPromises = products
    .filter(product => product.code) 
    .map(async (product) => {
      const specs = product.technicalSpecs || {};
      const brand = pickVal(product, specs, 'Marke', 'brand', 'Brand');
      const productType = resolveProductType(product);
      const model = pickVal(product, specs, 'Modell', 'model', 'Model');
      const mpn = product.code; // Use SKU as MPN
      const ean = pickVal(product, specs, 'EAN', 'ean', 'Barcode');
      const mainImage = product.images.find(img => img.isMain) || product.images[0];


      return [
      'Draft',
      product.code,
      product.ebayCategoryId,
      safeTitle(product.name),
      ean,
      product.price ? product.price.toFixed(2) : '0.00',
      product.quantity,
      safeImage(mainImage?.url),
      getEbayConditionId(product.listingStatus),
      cleanSemicolonCsvField(product.description),
      'FixedPrice',
      brand,
      productType,
      model,
      mpn,
    ].map(cleanSemicolonCsvField)
  });

  const dataRows = await Promise.all(dataRowsPromises);
  
  const ebayTemplateIdentifier = '#INFO;Version=0.0.2;Template= eBay-draft-listings-template_DE;;;;;;;';
  const csvBody = buildCsvBody(headers, dataRows.filter(Boolean) as string[][], ';');
  const finalCsv = [ UTF8_BOM + ebayTemplateIdentifier, csvBody ].join(EOL);
  
  return finalCsv.replace(/\n/g, '\r\n');
};


// --- Shopify Specific Logic ---

const getShopifyCondition = (status: Product['listingStatus']): string => {
  switch (status) {
    case 'new': return 'new';
    case 'used': return 'used';
    case 'refurbished': return 'refurbished';
    default: return 'new';
  }
};

const ensureValidImageSrc = (url?: string): string => {
    if (url && (url.startsWith('http://') || url.startsWith('https://'))) {
        return url;
    }
    return SHOPIFY_PLACEHOLDER_IMAGE;
};


const generateShopifyCsvContent = (products: Product[]): string => {
  const headers = [
    'Handle', 'Title', 'Body (HTML)', 'Vendor', 'Product Category', 'Type', 'Tags', 
    'Published', 'Option1 Name', 'Option1 Value', 'Variant SKU', 'Variant Grams', 
    'Variant Inventory Tracker', 'Variant Inventory Qty', 'Variant Inventory Policy',
    'Variant Fulfillment Service', 'Variant Price', 'Variant Requires Shipping', 
    'Variant Taxable', 'Variant Barcode', 'Image Src', 'Image Position', 'Image Alt Text', 
    'Gift Card', 'SEO Title', 'SEO Description', 
    'Google Shopping / Google Product Category', 'Google Shopping / Condition',
    'Google Shopping / MPN', 'Status'
  ];

  const dataRows = products
    .filter(product => product.code)
    .map(product => {
      const handle = product.name.toLowerCase().replace(/\s+/g, '-').replace(/[^a-z0-9-]/g, '');
      const mainImage = product.images.find(img => img.isMain) || product.images[0];
      const imageUrl = ensureValidImageSrc(mainImage?.url);
      const specs = product.technicalSpecs || {};
      const brand = pickVal(product, specs, 'Marke', 'brand', 'Brand');
      let productType = pickVal(product, specs, 'Produktart', 'productType', 'Type');
      if (!productType) productType = inferProductType(product.name, product.ebayCategoryId);
      
      const ean = pickVal(product, specs, 'EAN', 'ean', 'Barcode');
      const mpn = product.code; // Use SKU as MPN
      const weight = pickVal(product, specs, 'Gewicht', 'weight') || '0';


      const rowData: Record<string, any> = {
        'Handle': handle, 'Title': product.name, 'Body (HTML)': product.description,
        'Vendor': brand, 'Product Category': product.category, 'Type': productType,
        'Tags': (product.tags || []).join(', '), 'Published': 'true', 'Option1 Name': 'Title',
        'Option1 Value': 'Default Title', 'Variant SKU': product.code, 
        'Variant Grams': parseFloat(weight.replace(/[^0-9.]/g, '')) * 1000,
        'Variant Inventory Tracker': 'shopify', 'Variant Inventory Qty': product.quantity,
        'Variant Inventory Policy': 'deny', 'Variant Fulfillment Service': 'manual',
        'Variant Price': product.price ? product.price.toFixed(2) : '0.00', 'Variant Requires Shipping': 'true',
        'Variant Taxable': 'true', 'Variant Barcode': ean, 
        'Image Src': imageUrl, 'Image Position': '1', 'Image Alt Text': product.name,
        'Gift Card': 'false', 'SEO Title': `${product.name} - ${brand || ''}`,
        'SEO Description': product.description ? product.description.substring(0, 320) : '',
        'Google Shopping / Google Product Category': product.category,
        'Google Shopping / Condition': getShopifyCondition(product.listingStatus),
        'Google Shopping / MPN': mpn,
        'Status': 'active'
      };
      return headers.map(header => escapeCommaCsvField(rowData[header] ?? ''));
    });

  const rawCsv = buildCsvBody(headers, dataRows, ',');
  return UTF8_BOM + rawCsv.replace(/\n/g, '\r\n');
};


// --- Main Export Function ---

export const generateCsv = async (products: Product[], platform: Platform): Promise<string> => {
  switch (platform) {
    case 'ebay':
      return await generateEbayCsvContent(products);
    case 'shopify':
      // Shopify generation remains sync for now, but could be made async if needed
      return generateShopifyCsvContent(products);
    default:
      console.error(`Unsupported platform: ${platform}`);
      return '';
  }
};
