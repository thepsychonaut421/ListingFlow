// This file is generated by Firebase Studio
import type { Product, ProductImage } from './types';

// Helper function to safely get a value from different possible keys.
const pickVal = (
  product: Product,
  specs: Record<string, any>,
  ...keys: string[]
): string => {
   // Build a lowercase view of specs once for efficient, safe case-insensitive lookup.
  const specsLower = Object.fromEntries(
    Object.entries(specs).map(([kk, vv]) => [kk.toLowerCase(), vv])
  );

  for (const k of keys) {
    const keyLower = k.toLowerCase();
    const v =
      specs[k] ??                      // 1. Exact key on specs
      (product as any)[k] ??           // 2. Exact key on product
      specsLower[keyLower] ??          // 3. Case-insensitive key on specs
      (product as any)[keyLower];      // 4. Case-insensitive key on product
      
    if (v !== undefined && v !== null && String(v).trim() !== '') {
      return Array.isArray(v) ? v.join(', ') : String(v).trim();
    }
  }
  return '';
};


const dataUrlToBase64 = (dataUrl: string): string => {
  const comma = dataUrl.indexOf(',');
  return comma >= 0 ? dataUrl.slice(comma + 1) : dataUrl;
}

const toShopifyImages = (images: ProductImage[], productTitle: string) => {
  if (!images || images.length === 0) {
    return [];
  }

  // Sort images to ensure the main image is first, then by their original order.
  const sorted = [...images].sort((a, b) => {
    if (a.isMain && !b.isMain) return -1;
    if (!a.isMain && b.isMain) return 1;
    return 0; // Keep original order for the rest
  });

  return sorted.map((img, idx) => {
    const isDataUrl = img.url.startsWith('data:');
    const base: any = {
      position: idx + 1,
      alt: `${productTitle} - Image ${idx + 1}`,
    };
    if (isDataUrl) {
      return {
        ...base,
        attachment: dataUrlToBase64(img.url),
      };
    }
    return { ...base, src: img.url };
  });
}

// Maps our internal status to a valid Shopify product status.
const toShopifyStatus = (status: Product['listingStatus']): 'active' | 'draft' | 'archived' => {
    switch (status) {
        case 'active':
        case 'listed': // Treat legacy 'listed' as 'active'
            return 'active';
        case 'archived':
            return 'archived';
        case 'draft':
        case 'new':
        case 'used':
        case 'refurbished':
        case 'error':
        default:
            return 'draft'; // Default to 'draft' for all other cases
    }
}


// Main function to publish a product to Shopify
export async function publishToShopify(product: Product): Promise<any> {
    const shopUrl = process.env.SHOPIFY_STORE_URL;
    const accessToken = process.env.SHOPIFY_ADMIN_ACCESS_TOKEN;

    if (!shopUrl || !accessToken) {
        throw new Error('Shopify credentials (URL or Access Token) are not configured in environment variables.');
    }
    
    try {
        // More robust URL validation.
        const url = new URL(shopUrl);
        if (url.protocol !== 'https:' || !url.hostname.endsWith('myshopify.com')) {
             throw new Error(`The provided URL is not a valid Shopify store URL.`);
        }
    } catch (e: any) {
        // This will catch invalid URL formats and provide a much clearer error.
        throw new Error(`The Shopify Store URL configured ("${shopUrl}") is not a valid URL. It should look like https://your-store.myshopify.com. ${e.message}`);
    }


    const specs = product.technicalSpecs || {};
    const brand = pickVal(product, specs, 'Marke', 'brand', 'Brand');
    const productType = pickVal(product, specs, 'Produktart', 'productType', 'Type');
    const ean = pickVal(product, specs, 'EAN', 'ean', 'Barcode');
    const weightInGrams = parseFloat(pickVal(product, specs, 'Gewicht', 'weight').replace(/[^0-9.]/g, '')) * 1000 || 0;
    
    // Map ListingFlow status to a valid Shopify status
    const shopifyStatus = toShopifyStatus(product.listingStatus);

    const shopifyProduct = {
        product: {
            title: product.name,
            body_html: product.description || '',
            vendor: brand,
            product_type: productType,
            tags: product.tags ? product.tags.join(', ') : '',
            status: shopifyStatus,
            images: toShopifyImages(product.images, product.name),
            variants: [
                {
                    price: product.price,
                    sku: product.code,
                    inventory_management: 'shopify',
                    inventory_policy: 'deny',
                    inventory_quantity: product.quantity,
                    barcode: ean,
                    weight: weightInGrams > 0 ? weightInGrams : undefined,
                    weight_unit: weightInGrams > 0 ? 'g' : undefined,
                    requires_shipping: true,
                    taxable: true,
                }
            ],
            product_category: product.category ? { product_taxonomy_node_id: product.category } : undefined,
        }
    };
    
    const endpoint = `${shopUrl.replace(/\/$/, '')}/admin/api/2024-04/products.json`;

    const response = await fetch(endpoint, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'X-Shopify-Access-Token': accessToken,
        },
        body: JSON.stringify(shopifyProduct),
        cache: 'no-store'
    });

    const responseBody = await response.json();
    if (!response.ok) {
        const errorMessage = responseBody.errors ? JSON.stringify(responseBody.errors) : 'An unknown error occurred.';
        throw new Error(`Shopify API Error: ${response.status} - ${errorMessage}`);
    }

    return responseBody;
}
