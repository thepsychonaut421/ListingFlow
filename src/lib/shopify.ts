
// This file is generated by Firebase Studio
import type { Product, ProductImage } from './types';

type ShopifyStoreConfig = {
  name: string;
  url: string;
  token: string;
};

// Helper function to safely get a value from different possible keys.
const pickVal = (
  product: Product,
  specs: Record<string, any>,
  ...keys: string[]
): string => {
   // Build a lowercase view of specs once for efficient, safe case-insensitive lookup.
  const specsLower = Object.fromEntries(
    Object.entries(specs).map(([kk, vv]) => [kk.toLowerCase(), vv])
  );

  for (const k of keys) {
    const keyLower = k.toLowerCase();
    const v =
      specs[k] ??                      // 1. Exact key on specs
      (product as any)[k] ??           // 2. Exact key on product
      specsLower[keyLower] ??          // 3. Case-insensitive key on specs
      (product as any)[keyLower];      // 4. Case-insensitive key on product
      
    if (v !== undefined && v !== null && String(v).trim() !== '') {
      return Array.isArray(v) ? v.join(', ') : String(v).trim();
    }
  }
  return '';
};


const dataUrlToBase64 = (dataUrl: string): string => {
  const comma = dataUrl.indexOf(',');
  return comma >= 0 ? dataUrl.slice(comma + 1) : dataUrl;
}

const toShopifyImages = (images: ProductImage[], productTitle: string) => {
  if (!images || images.length === 0) {
    return [];
  }

  // Sort images to ensure the main image is first, then by their original order.
  const sorted = [...images].sort((a, b) => {
    if (a.isMain && !b.isMain) return -1;
    if (!a.isMain && b.isMain) return 1;
    return 0; // Keep original order for the rest
  });

  return sorted.map((img, idx) => {
    const isDataUrl = img.url.startsWith('data:');
    const base: any = {
      position: idx + 1,
      alt: `${productTitle} - Image ${idx + 1}`,
    };
    if (isDataUrl) {
      return {
        ...base,
        attachment: dataUrlToBase64(img.url),
      };
    }
    return { ...base, src: img.url };
  });
}

// Maps our internal status to a valid Shopify product status.
const toShopifyStatus = (status: Product['listingStatus']): 'active' | 'draft' | 'archived' => {
    switch (status) {
        case 'active':
        case 'listed': // Treat legacy 'listed' as 'active'
            return 'active';
        case 'archived':
            return 'archived';
        case 'draft':
        case 'new':
        case 'used':
        case 'refurbished':
        case 'error':
        default:
            return 'draft'; // Default to 'draft' for all other cases
    }
}


// Main function to publish a product to Shopify
export async function publishToShopify(product: Product, storeName: string): Promise<any> {
    const storesJson = process.env.SHOPIFY_STORES;
    if (!storesJson) {
      throw new Error("SHOPIFY_STORES environment variable is not set on the server.");
    }
    
    let stores: ShopifyStoreConfig[];
    try {
        stores = JSON.parse(storesJson);
    } catch (e) {
        throw new Error("Failed to parse SHOPIFY_STORES. Please ensure it's a valid JSON array.");
    }

    const store = stores.find(s => s.name === storeName);
    if (!store) {
        throw new Error(`Shopify store configuration for "${storeName}" not found.`);
    }

    const { url: shopUrl, token: accessToken } = store;

    if (!shopUrl || !accessToken || !accessToken.startsWith('shpat_')) {
        throw new Error(`Invalid Shopify credentials for store "${storeName}". Ensure URL is correct and token is a valid Admin API token starting with 'shpat_'.`);
    }

    const specs = product.technicalSpecs || {};
    const brand = pickVal(product, specs, 'Marke', 'brand', 'Brand');
    const productType = pickVal(product, specs, 'Produktart', 'productType', 'Type');
    const ean = pickVal(product, specs, 'EAN', 'ean', 'Barcode');
    const weightInGrams = parseFloat(pickVal(product, specs, 'Gewicht', 'weight').replace(/[^0-9.]/g, '')) * 1000 || 0;
    
    const shopifyStatus = toShopifyStatus(product.listingStatus);

    const shopifyProduct = {
        product: {
            title: product.name,
            body_html: product.description || '',
            vendor: brand,
            product_type: productType,
            tags: product.tags ? product.tags.join(', ') : '',
            status: shopifyStatus,
            images: toShopifyImages(product.images, product.name),
            variants: [
                {
                    price: product.price,
                    sku: product.code,
                    inventory_management: 'shopify',
                    inventory_policy: 'deny',
                    inventory_quantity: product.quantity,
                    barcode: ean,
                    weight: weightInGrams > 0 ? weightInGrams : undefined,
                    weight_unit: weightInGrams > 0 ? 'g' : undefined,
                    requires_shipping: true,
                    taxable: true,
                }
            ],
        }
    };
    
    const endpoint = `https://${shopUrl.replace(/^(https?:\/\/)?/, '')}/admin/api/2024-07/products.json`;

    const response = await fetch(endpoint, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'X-Shopify-Access-Token': accessToken,
        },
        body: JSON.stringify(shopifyProduct),
        cache: 'no-store'
    });

    if (!response.ok) {
        const responseBody = await response.json().catch(() => ({}));
        let errorMessage = responseBody.errors ? JSON.stringify(responseBody.errors) : 'An unknown error occurred.';
        
        if (response.status === 401) {
             errorMessage = `Authentication failed for store "${storeName}". The provided Admin API Access Token is invalid or does not have the required permissions (e.g., 'write_products'). Please verify your secrets.`;
        }
        
        throw new Error(`Shopify API Error: ${response.status} - ${errorMessage}`);
    }

    return response.json();
}
