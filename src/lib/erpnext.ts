// This file is generated by Firebase Studio
import type { Product, ProductImage } from './types';

/**
 * A generic fetch wrapper for making API calls to the ERPNext proxy route.
 * This centralizes API calls and ensures they all go through the secure server-side proxy
 * where environment variables and secrets are properly handled.
 *
 * @param endpoint The ERPNext API endpoint (e.g., /api/resource/Item).
 * @param init The standard RequestInit object for fetch (method, body, etc.).
 * @returns The JSON response from the API.
 * @throws An error if the request fails or returns a non-ok status.
 */
async function erpFetch(endpoint: string, init?: RequestInit) {
  try {
    const response = await fetch('/api/proxy-erpnext', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
            endpoint,
            method: init?.method || 'GET',
            body: init?.body ? JSON.parse(init.body as string) : undefined,
        }),
        cache: 'no-store',
    });

    if (!response.ok) {
        let errorBody;
        try {
          errorBody = await response.json();
        } catch(e) {
          const errorText = await response.text();
          throw new Error(`Request to proxy for ${endpoint} failed with status ${response.status}: ${errorText}`);
        }
        
        let errorMessage = `Request to proxy for ${endpoint} failed with status ${response.status}`;

        if (errorBody && errorBody.error) {
           errorMessage = errorBody.error;
        } else if (errorBody && errorBody.exception?.includes("AuthenticationError")) {
           errorMessage = "Authentication Error. Please check your ERPNext API Key and Secret.";
        }
        
        throw new Error(errorMessage);
    }
    
    // Handle successful but empty responses (e.g., from PUT or DELETE)
    if (response.status === 204) {
      return null;
    }

    return response.json();

  } catch (err: any) {
    console.error(`ERPNext proxy fetch error for endpoint ${endpoint}:`, err);
    // Re-throw the error with a more specific message if possible, otherwise use the original.
    throw new Error(err.message || `Failed to communicate with ERPNext via proxy.`);
  }
}


/**
 * Performs a preflight check to ensure API credentials are valid.
 * @returns The logged-in user's email if successful.
 * @throws An error if authentication fails.
 */
export async function erpPing(): Promise<string> {
  const data = await erpFetch(`/api/method/frappe.auth.get_logged_user`);
  if (!data || data.message === 'Guest') {
    throw new Error('Authentication failed. Please check your ERPNext API Key and Secret.');
  }
  return data.message as string; // email of the logged-in user
}


/**
 * Builds a comprehensive description string from product data,
 * including its base description and all technical specifications.
 * @param product The product object.
 * @returns A formatted string ready to be used as a description.
 */
const buildFullDescription = (product: Product): string => {
  let fullDescription = product.description || '';

  // Retrieve brand and productType from specs
  const specs = { ...product.technicalSpecs };
  const brand = specs.Marke || specs.brand;
  const productType = specs['Produktart'];
  
  const mainSpecs: Record<string, any> = {};
  if (brand) mainSpecs['Marke'] = brand;
  if (productType) mainSpecs['Produktart'] = productType;
  
  const allSpecs = { ...mainSpecs, ...specs };

  const specEntries = Object.entries(allSpecs)
    .map(([key, value]) => {
      if (!value || key.toLowerCase() === 'brand' || key.toLowerCase() === 'marke' || key.toLowerCase() === 'produktart') return null; // Skip if value is empty or it's a main spec
      const formattedValue = Array.isArray(value) ? value.join(', ') : value;
      // Capitalize the first letter of the key
      const formattedKey = key.charAt(0).toUpperCase() + key.slice(1);
      return `${formattedKey}: ${formattedValue}`;
    })
    .filter(Boolean); // Remove null entries

  if (specEntries.length > 0) {
    fullDescription += '\n\n<hr>\n\n<h3>Technische Daten:</h3>\n<ul>\n';
    specEntries.forEach(entry => {
      fullDescription += `  <li>${entry}</li>\n`;
    });
    fullDescription += '</ul>';
  }

  return fullDescription.trim();
};


// 4. Export modificări către ERPNext
export async function exportProductsToERPNext(
  setLoading: (b: boolean) => void, // This is a dummy, can be removed if not used client-side
  productsToExport: Product[]
): Promise<{ successCount: number, errorMessages: string[] }> {
    await erpPing(); // Preflight check

    const isProd = process.env.NEXT_PUBLIC_ENV === 'prod';
    if (isProd) {
        // This check will only work client-side, but the function is now server-side.
        // It's a harmless check that will just be skipped on the server.
        if (typeof window !== 'undefined' && !window.confirm(`⚠️ You are about to export ${productsToExport.length} products to the PRODUCTION ERP environment. Are you sure you want to continue?`)) {
            throw new Error("User cancelled production export.");
        }
    }

    let successCount = 0;
    let errorMessages: string[] = [];

    for (const p of productsToExport) {
        const fullDescription = buildFullDescription(p);
        const brand = (p.technicalSpecs?.Marke || p.technicalSpecs?.brand || '') as string;
        
        const itemPayload: Record<string, any> = {
            item_code: p.code, // Essential field for identifying the item
            item_name: p.name,
            standard_rate: p.price,
            description: fullDescription,
            web_long_description: fullDescription,
        };

        if(brand) {
            itemPayload.brand = brand;
        }

        try {
            await erpFetch(`/api/resource/Item/${p.code}`, { method: 'PUT', body: JSON.stringify(itemPayload) });
            successCount++;
        } catch (error: any) {
             const message = `Failed to export product ${p.code}: ${error.message}`;
             console.error(message);
             errorMessages.push(message);
        }
    }
    
    return { successCount, errorMessages };
}
