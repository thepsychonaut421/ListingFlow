// This file is generated by Firebase Studio
'use client';

import type { Product } from './types';

// 1. Helper API general
async function erpNextRequest(endpoint: string, method: string = 'GET', body?: any) {
  const credsJSON = localStorage.getItem('erpnext-credentials');
  if (!credsJSON) {
    throw new Error('Missing ERPNext credentials. Please save them in Settings.');
  }
  
  const creds = JSON.parse(credsJSON);
  if (!creds.url || !creds.apiKey || !creds.apiSecret) {
    throw new Error('Incomplete ERPNext credentials. Please check them in Settings.');
  }

  const headers: Record<string, string> = {
    'Authorization': `token ${creds.apiKey}:${creds.apiSecret}`,
    'Content-Type': 'application/json'
  };

  const res = await fetch(`${creds.url}${endpoint}`, {
    method,
    headers,
    body: body ? JSON.stringify(body) : undefined,
    cache: 'no-store', // Ensure fresh data is fetched every time
  });

  if (!res.ok) {
    const errText = await res.text();
    let errorDetails = '';
    try {
        const errJson = JSON.parse(errText);
        errorDetails = errJson.message || errJson.exception || errText;
    } catch {
        errorDetails = errText;
    }
    throw new Error(`ERPNext API error: ${res.status} - ${errorDetails}`);
  }

  return res.json();
}

// 2. Import produse din ERPNext
export async function importProductsFromERPNext(
  setLoading: (b: boolean) => void,
  setProducts: (products: Product[]) => void
) {
  try {
    setLoading(true);

    const itemsData = await erpNextRequest('/api/resource/Item?fields=["name","item_code","item_name","standard_rate","brand","ean"]&limit=100');

    const importedProducts = await Promise.all(itemsData.data.map(async (item: any) => {
      let qty = 0;
      try {
        const binData = await erpNextRequest(`/api/resource/Bin?filters=[["item_code","=","${item.name}"]]&fields=["actual_qty"]`);
        qty = binData.data.reduce((acc: number, curr: any) => acc + curr.actual_qty, 0);
      } catch (err) {
        console.warn(`No Bin data for item ${item.name}`, err);
      }

      return {
        id: item.name, // Use ERPNext's unique name as the ID
        name: item.item_name || item.name,
        code: item.name,
        price: item.standard_rate || 0,
        quantity: qty,
        description: '',
        image: '',
        supplier: '',
        location: '',
        tags: [],
        keywords: [],
        category: '',
        ebayCategoryId: '',
        listingStatus: 'draft',
        brand: item.brand || '',
        productType: '',
        ean: item.ean || '',
        technicalSpecs: {},
      } as Product;
    }));

    setProducts(importedProducts);
    alert(`Successfully imported ${importedProducts.length} products from ERPNext.`);
  } catch (err: any) {
    console.error(err);
    alert(`Import failed: ${err.message}`);
  } finally {
    setLoading(false);
  }
}

// 3. Update prețuri/stocuri din ERPNext
export async function updatePricesAndStocksFromERPNext(
  setLoading: (b: boolean) => void,
  setProducts: (fn: (products: Product[]) => Product[]) => void,
  currentProducts: Product[]
) {
  try {
    setLoading(true);

    if (!currentProducts.length) {
      alert('No products loaded in ListingFlow to update.');
      return;
    }

    let updatedCount = 0;
    const updatedProductsPromises = currentProducts.map(async (p: Product) => {
      let price = p.price;
      let qty = p.quantity;
      let hasUpdate = false;

      try {
        const details = await erpNextRequest(`/api/resource/Item/${p.code}?fields=["standard_rate"]`);
        const newPrice = details.data.standard_rate;
        if (newPrice !== undefined && newPrice !== price) {
          price = newPrice;
          hasUpdate = true;
        }
      } catch (err) {
        console.warn(`Could not update price for ${p.code}`, err);
      }

      try {
        const binData = await erpNextRequest(`/api/resource/Bin?filters=[["item_code","=","${p.code}"]]&fields=["actual_qty"]`);
        const newQty = binData.data.reduce((acc: number, curr: any) => acc + curr.actual_qty, 0);
        if (newQty !== qty) {
          qty = newQty;
          hasUpdate = true;
        }
      } catch (err) {
        console.warn(`Could not update stock for ${p.code}`, err);
      }
      
      if(hasUpdate) updatedCount++;
      return { ...p, price, quantity: qty };
    });
    
    const updatedProducts = await Promise.all(updatedProductsPromises);

    setProducts(() => updatedProducts);
    alert(`Update complete. ${updatedCount} products were updated with new data from ERPNext.`);
  } catch (err: any) {
    console.error(err);
    alert(`Update failed: ${err.message}`);
  } finally {
    setLoading(false);
  }
}

// 4. Export modificări către ERPNext
export async function exportProductsToERPNext(
  setLoading: (b: boolean) => void,
  productsToExport: Product[]
) {
  try {
    setLoading(true);

    if (!productsToExport.length) {
      alert('No products to export.');
      return;
    }

    let successCount = 0;
    for (const p of productsToExport) {
      try {
        await erpNextRequest(`/api/resource/Item/${p.code}`, 'PUT', {
          standard_rate: p.price,
          // Note: ERPNext does not allow direct update of `actual_qty`.
          // This requires creating a Stock Entry document.
          // This export only updates the price.
        });
        successCount++;
      } catch (err) {
          console.error(`Failed to export product ${p.code}:`, err);
      }
    }

    alert(`Export complete. Successfully updated ${successCount}/${productsToExport.length} products in ERPNext.`);
  } catch (err: any) {
    console.error(err);
    alert(`Export failed: ${err.message}`);
  } finally {
    setLoading(false);
  }
}

// 5. Universal Search Function
export async function searchInERPNext(
  doctype: string,
  filters: any[][],
  fields: string[],
  pageLength = 20,
  start = 0
): Promise<any[]> {
  try {
    const filtersParam = encodeURIComponent(JSON.stringify(filters));
    const fieldsParam = encodeURIComponent(JSON.stringify(fields));
    const endpoint = `/api/resource/${doctype}?filters=${filtersParam}&fields=${fieldsParam}&limit_start=${start}&limit_page_length=${pageLength}`;
    const resp = await erpNextRequest(endpoint);
    return resp.data || [];
  } catch(err) {
    console.error(`Search in ${doctype} failed:`, err);
    // Return empty array in case of error to avoid breaking the UI
    return [];
  }
}