// This file is generated by Firebase Studio
'use client';

import type { Product } from './types';

// Helper function to call our new server-side proxy
async function erpNextRequest(
  endpoint: string,
  method: 'GET' | 'POST' | 'PUT' | 'PATCH' | 'DELETE' = 'GET',
  body?: any
) {
  const response = await fetch('/api/proxy-erpnext', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({ endpoint, method, body }),
  });

  if (!response.ok) {
    const errorBody = await response.json().catch(() => ({ error: response.statusText }));
    throw new Error(`ERPNext API error: ${errorBody.error || response.statusText}`);
  }
  
  // Handle cases with no content in response
  if (response.status === 204) {
    return null;
  }
  
  return response.json();
}


// 2. Import produse din ERPNext
export async function importProductsFromERPNext(
  setLoading: (b: boolean) => void,
  setProducts: (products: Product[]) => void,
  currentProducts: Product[]
) {
  try {
    setLoading(true);

    const itemsData = await erpNextRequest('/api/resource/Item?fields=["name","item_code","item_name","standard_rate","brand"]&limit=100');
    
    if (!itemsData || !itemsData.data || itemsData.data.length === 0) {
      alert('No products found in ERPNext to import.');
      return;
    }

    // Create a map of existing product SKUs for quick lookup
    const existingSkuMap = new Set(currentProducts.map(p => p.code));
    
    const newItems = itemsData.data.filter((item: any) => !existingSkuMap.has(item.name));

    if (newItems.length === 0) {
        alert('All ERPNext products are already in ListingFlow. Use "Update from ERPNext" to sync data.');
        return;
    }

    const importedProducts = await Promise.all(newItems.map(async (item: any) => {
      let qty = 0;
      try {
        const binData = await erpNextRequest(`/api/resource/Bin?filters=[["item_code","=","${item.name}"]]&fields=["actual_qty"]`);
        qty = binData.data.reduce((acc: number, curr: any) => acc + curr.actual_qty, 0);
      } catch (err) {
        console.warn(`No Bin data for item ${item.name}`, err);
      }

      return {
        id: item.name, // Use ERPNext's unique name as the ID
        name: item.item_name || item.name,
        code: item.name,
        price: item.standard_rate || 0,
        quantity: qty,
        description: '',
        image: '',
        supplier: '',
        location: '',
        tags: [],
        keywords: [],
        category: '',
        ebayCategoryId: '',
        listingStatus: 'draft',
        brand: item.brand || '',
        productType: '',
        ean: item.ean || '',
        technicalSpecs: {},
      } as Product;
    }));

    setProducts([...importedProducts, ...currentProducts]);
    alert(`Successfully imported ${importedProducts.length} new products from ERPNext.`);
  } catch (err: any) {
    console.error(err);
    alert(`Import failed: ${err.message}`);
  } finally {
    setLoading(false);
  }
}

// 3. Update prețuri/stocuri din ERPNext
export async function updatePricesAndStocksFromERPNext(
  setLoading: (b: boolean) => void,
  setProducts: (fn: (products: Product[]) => Product[]) => void,
  currentProducts: Product[]
) {
  try {
    setLoading(true);

    if (!currentProducts.length) {
      alert('No products loaded in ListingFlow to update.');
      return;
    }

    let updatedCount = 0;
    const updatedProductsPromises = currentProducts.map(async (p: Product) => {
      let price = p.price;
      let qty = p.quantity;
      let hasUpdate = false;

      try {
        const details = await erpNextRequest(`/api/resource/Item/${p.code}?fields=["standard_rate"]`);
        const newPrice = details.data.standard_rate;
        if (newPrice !== undefined && newPrice !== price) {
          price = newPrice;
          hasUpdate = true;
        }
      } catch (err) {
        console.warn(`Could not update price for ${p.code}`, err);
      }

      try {
        const binData = await erpNextRequest(`/api/resource/Bin?filters=[["item_code","=","${p.code}"]]&fields=["actual_qty"]`);
        const newQty = binData.data.reduce((acc: number, curr: any) => acc + curr.actual_qty, 0);
        if (newQty !== qty) {
          qty = newQty;
          hasUpdate = true;
        }
      } catch (err) {
        console.warn(`Could not update stock for ${p.code}`, err);
      }
      
      if(hasUpdate) updatedCount++;
      return { ...p, price, quantity: qty };
    });
    
    const updatedProducts = await Promise.all(updatedProductsPromises);

    setProducts(() => updatedProducts);
    alert(`Update complete. ${updatedCount} products were updated with new data from ERPNext.`);
  } catch (err: any) {
    console.error(err);
    alert(`Update failed: ${err.message}`);
  } finally {
    setLoading(false);
  }
}

// 4. Export modificări către ERPNext
export async function exportProductsToERPNext(
  setLoading: (b: boolean) => void,
  productsToExport: Product[]
) {
  try {
    setLoading(true);

    if (!productsToExport.length) {
      alert('No products to export.');
      return;
    }

    let successCount = 0;
    for (const p of productsToExport) {
      try {
        // We only update fields that are safe to update.
        // We do not update stock level as that requires a Stock Entry.
        await erpNextRequest(`/api/resource/Item/${p.code}`, 'PUT', {
          item_name: p.name,
          standard_rate: p.price,
          brand: p.brand,
          ean: p.ean
        });
        successCount++;
      } catch (err) {
          console.error(`Failed to export product ${p.code}:`, err);
      }
    }

    alert(`Export complete. Successfully updated ${successCount}/${productsToExport.length} products in ERPNext.`);
  } catch (err: any) {
    console.error(err);
    alert(`Export failed: ${err.message}`);
  } finally {
    setLoading(false);
  }
}

// 5. Universal Search Function
export async function searchInERPNext(
  doctype: string,
  filters: any[][],
  fields: string[],
  pageLength = 20,
  start = 0
): Promise<any[]> {
  try {
    // The standard API does not support OR filters, it treats arrays of filters as AND.
    // To simulate an OR, we have to make separate requests and combine the results.
    const requests = filters.map(filter => {
       const endpoint = `/api/resource/${doctype}?filters=${JSON.stringify([filter])}&fields=${JSON.stringify(fields)}&limit_start=${start}&limit_page_length=${pageLength}`;
       return erpNextRequest(endpoint);
    });

    const responses = await Promise.all(requests);
    const allResults = responses.flatMap(resp => resp.data || []);
    
    // Remove duplicates based on the 'name' field, which is the unique ID in ERPNext
    const uniqueResults = allResults.filter((item, index, self) =>
        index === self.findIndex((t) => t.name === item.name)
    );

    return uniqueResults;
  } catch(err) {
    console.error(`Search in ${doctype} failed:`, err);
    // Return empty array in case of error to avoid breaking the UI
    return [];
  }
}
