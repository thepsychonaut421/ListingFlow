// This file is generated by Firebase Studio
'use client';

import type { Product } from './types';

function erpHeaders() {
  const key = process.env.ERPNEXT_API_KEY;
  const secret = process.env.ERPNEXT_API_SECRET;
  if (!key || !secret) {
    throw new Error('ERPNext API Key/Secret is not configured in environment variables.');
  }
  return {
    'Authorization': `token ${key}:${secret}`,
    'Content-Type': 'application/json',
    'Accept': 'application/json',
  };
}

async function erpFetch(path: string, init?: RequestInit) {
  const base = process.env.ERPNEXT_BASE_URL;
  if (!base) {
    throw new Error('ERPNEXT_BASE_URL is not configured in environment variables.');
  }
  
  const url = `${base.replace(/\/$/, '')}${path}`;
  
  try {
    const response = await fetch(url, {
      ...init,
      headers: { ...erpHeaders(), ...(init?.headers as any) },
      cache: 'no-store',
    });

    if (!response.ok) {
      let errorDetails;
      try {
        const errorBody = await response.json();
        // Frappe often wraps the real error in _server_messages
        if (errorBody._server_messages) {
          const serverMessage = JSON.parse(errorBody._server_messages[0]);
          errorDetails = serverMessage.message || JSON.stringify(serverMessage);
        } else {
          errorDetails = errorBody.message || errorBody.exception || errorBody.error || JSON.stringify(errorBody);
        }
      } catch (e) {
        errorDetails = await response.text();
      }
      throw new Error(`ERPNext request to ${path} failed with status ${response.status}: ${errorDetails}`);
    }
    
    if (response.status === 204) {
      return null;
    }

    return response.json();
  } catch (err: any) {
    console.error(`ERPNext fetch error for path ${path}:`, err);
    // Re-throw a more informative error
    throw new Error(`Failed to communicate with ERPNext at ${url}. Please check the URL and credentials. Original error: ${err.message}`);
  }
}

/**
 * Performs a preflight check to ensure API credentials are valid.
 * @returns The logged-in user's email if successful.
 * @throws An error if authentication fails.
 */
export async function erpPing(): Promise<string> {
  const data = await erpFetch(`/api/method/frappe.auth.get_logged_user`);
  if (data.message === 'Guest') {
    throw new Error('Authentication failed: credentials are for a Guest user.');
  }
  if (!data.message) {
    throw new Error('Authentication check failed: unexpected response from ERPNext.');
  }
  return data.message as string; // email of the logged-in user
}


const ERPNEXT_ITEM_FIELDS = [
  'name', 'item_code', 'item_name', 'standard_rate', 'image', 'description', 'web_long_description', 'modified'
];

function pickDescription(item: any): string {
    return item.web_long_description?.trim() || item.description?.trim() || '';
}

function shouldOverwrite(erpModified: string, localProduct?: Product): boolean {
  if (!localProduct?.description) return true; // Always write if local description is empty
  if (!localProduct?.sourceModified) return true; // Always write if we don't have a source timestamp
  return new Date(erpModified).getTime() > new Date(localProduct.sourceModified).getTime();
}

// 2. Import produse din ERPNext
export async function importProductsFromERPNext(
  setLoading: (b: boolean) => void,
  setProducts: (fn: (products: Product[]) => Product[]) => void,
  currentProducts: Product[]
) {
  try {
    setLoading(true);
    await erpPing(); // Preflight check

    let allItems: any[] = [];
    const pageSize = 100; // Fetch in batches of 100
    let start = 0;
    let hasMore = true;

    while (hasMore) {
      const itemsData = await erpFetch(`/api/resource/Item?fields=${JSON.stringify(ERPNEXT_ITEM_FIELDS)}&limit_start=${start}&limit_page_length=${pageSize}`);
      
      if (itemsData && itemsData.data && itemsData.data.length > 0) {
        allItems = allItems.concat(itemsData.data);
        start += pageSize;
      } else {
        hasMore = false;
      }
    }

    if (allItems.length === 0) {
      alert('No products found in ERPNext to import.');
      setLoading(false);
      return;
    }

    // Create a map of existing products for quick lookup
    const productMap = new Map(currentProducts.map(p => [p.code, p]));
    let newCount = 0;
    let updatedCount = 0;
    
    const erpNextUrl = process.env.NEXT_PUBLIC_ERPNEXT_BASE_URL || '';

    const upsertedProducts = await Promise.all(allItems.map(async (item: any) => {
        const existingProduct = productMap.get(item.name);
        const imageUrl = item.image ? (erpNextUrl.replace(/\/$/, '') + item.image) : '';
        let qty = existingProduct?.quantity || 0;

        try {
            const binData = await erpFetch(`/api/resource/Bin?filters=[["item_code","=","${item.name}"]]&fields=["actual_qty"]`);
            qty = binData.data.reduce((acc: number, curr: any) => acc + curr.actual_qty, 0);
        } catch (err) {
            console.warn(`No Bin data for item ${item.name}`, err);
        }

        if (existingProduct) {
             // UPDATE logic
            if (shouldOverwrite(item.modified, existingProduct)) {
                updatedCount++;
                return {
                    ...existingProduct,
                    name: item.item_name || item.name,
                    price: item.standard_rate || 0,
                    images: imageUrl ? [imageUrl] : [],
                    description: pickDescription(item),
                    sourceModified: item.modified,
                    quantity: qty,
                };
            }
            return existingProduct;
        } else {
            // CREATE logic
            newCount++;
            return {
                id: item.name,
                name: item.item_name || item.name,
                code: item.name,
                price: item.standard_rate || 0,
                quantity: qty,
                description: pickDescription(item),
                images: imageUrl ? [imageUrl] : [],
                sourceModified: item.modified,
                supplier: '', location: '', tags: [], keywords: [], category: '',
                ebayCategoryId: '', listingStatus: 'draft',
                technicalSpecs: {},
            } as Product;
        }
    }));


    setProducts(() => upsertedProducts);
    alert(`Import complete. ${newCount} new products added, ${updatedCount} products updated from ERPNext.`);
  } catch (err: any) {
    console.error(err);
    alert(`Import failed: ${err.message}. Please check your ERPNext connection settings.`);
  } finally {
    setLoading(false);
  }
}

// 3. Update prețuri/stocuri/imagini din ERPNext
export async function updatePricesAndStocksFromERPNext(
  setLoading: (b: boolean) => void,
  setProducts: (fn: (products: Product[]) => Product[]) => void,
  currentProducts: Product[]
) {
  try {
    setLoading(true);
    await erpPing(); // Preflight check

    if (!currentProducts.length) {
      alert('No products loaded in ListingFlow to update.');
      return;
    }

    let updatedCount = 0;
    
    const erpNextUrl = process.env.NEXT_PUBLIC_ERPNEXT_BASE_URL || '';

    const updatedProductsPromises = currentProducts.map(async (p: Product) => {
      let hasUpdate = false;
      
      try {
        const details = await erpFetch(`/api/resource/Item/${p.code}?fields=${JSON.stringify(ERPNEXT_ITEM_FIELDS)}`);
        const itemData = details.data;
        const newProductData = { ...p };

        const newPrice = itemData.standard_rate;
        if (newPrice !== undefined && newPrice !== p.price) {
          newProductData.price = newPrice;
          hasUpdate = true;
        }
        
        const newImage = itemData.image ? (erpNextUrl.replace(/\/$/, '') + itemData.image) : '';
        if (newImage && (!p.images || !p.images.includes(newImage))) {
            newProductData.images = [newImage];
            hasUpdate = true;
        }
        
        if (shouldOverwrite(itemData.modified, p)) {
            newProductData.description = pickDescription(itemData);
            newProductData.sourceModified = itemData.modified;
            hasUpdate = true;
        }

        const binData = await erpFetch(`/api/resource/Bin?filters=[["item_code","=","${p.code}"]]&fields=["actual_qty"]`);
        const newQty = binData.data.reduce((acc: number, curr: any) => acc + curr.actual_qty, 0);
        if (newQty !== p.quantity) {
          newProductData.quantity = newQty;
          hasUpdate = true;
        }
        
        if(hasUpdate) updatedCount++;
        return newProductData;

      } catch (err) {
        console.warn(`Could not update details for ${p.code}`, err);
        return p; // Return original product on error
      }
    });
    
    const updatedProducts = await Promise.all(updatedProductsPromises);

    setProducts(() => updatedProducts);
    alert(`Update complete. ${updatedCount} products were updated with new data from ERPNext.`);
  } catch (err: any)
 {
    console.error(err);
    alert(`Update failed: ${err.message}. Please check your ERPNext connection settings.`);
  } finally {
    setLoading(false);
  }
}


/**
 * Builds a comprehensive description string from product data,
 * including its base description and all technical specifications.
 * @param product The product object.
 * @returns A formatted string ready to be used as a description.
 */
const buildFullDescription = (product: Product): string => {
  let fullDescription = product.description || '';

  // Retrieve brand and productType from specs
  const specs = { ...product.technicalSpecs };
  const brand = specs.Marke || specs.brand;
  const productType = specs['Produktart'];
  
  const mainSpecs: Record<string, any> = {};
  if (brand) mainSpecs['Marke'] = brand;
  if (productType) mainSpecs['Produktart'] = productType;
  
  const allSpecs = { ...mainSpecs, ...specs };

  const specEntries = Object.entries(allSpecs)
    .map(([key, value]) => {
      if (!value || key.toLowerCase() === 'brand' || key.toLowerCase() === 'marke' || key.toLowerCase() === 'produktart') return null; // Skip if value is empty or it's a main spec
      const formattedValue = Array.isArray(value) ? value.join(', ') : value;
      // Capitalize the first letter of the key
      const formattedKey = key.charAt(0).toUpperCase() + key.slice(1);
      return `${formattedKey}: ${formattedValue}`;
    })
    .filter(Boolean); // Remove null entries

  if (specEntries.length > 0) {
    fullDescription += '\n\n<hr>\n\n<h3>Technische Daten:</h3>\n<ul>\n';
    specEntries.forEach(entry => {
      fullDescription += `  <li>${entry}</li>\n`;
    });
    fullDescription += '</ul>';
  }

  return fullDescription.trim();
};


// 4. Export modificări către ERPNext
export async function exportProductsToERPNext(
  setLoading: (b: boolean) => void,
  productsToExport: Product[]
) {
  try {
    setLoading(true);
    const loggedInUser = await erpPing(); // Preflight check

    const isProd = process.env.NEXT_PUBLIC_ENV === 'prod';
    if (isProd) {
        if (!confirm(`⚠️ You are about to export ${productsToExport.length} products to the PRODUCTION ERP environment as "${loggedInUser}".\n\nAre you sure you want to continue?`)) {
            setLoading(false);
            return;
        }
    }


    if (!productsToExport.length) {
      alert('No products to export.');
      return;
    }

    let successCount = 0;
    let errorMessages: string[] = [];

    for (const p of productsToExport) {
        const fullDescription = buildFullDescription(p);
        const brand = (p.technicalSpecs?.Marke || p.technicalSpecs?.brand || '') as string;
        
        const itemPayload: Record<string, any> = {
            item_code: p.code, // Essential field for identifying the item
            item_name: p.name,
            standard_rate: p.price,
            description: fullDescription,
            web_long_description: fullDescription,
        };

        if(brand) {
            itemPayload.brand = brand;
        }

        try {
            await erpFetch(`/api/resource/Item/${p.code}`, { method: 'PUT', body: JSON.stringify(itemPayload) });
            successCount++;
        } catch (error: any) {
             const message = `Failed to export product ${p.code}: ${error.message}`;
             console.error(message);
             errorMessages.push(message);
        }
    }

    if (errorMessages.length > 0) {
      alert(`Export partially complete. 
Successfully updated ${successCount}/${productsToExport.length} products.
Errors encountered:
- ${errorMessages.join('\n- ')}`);
    } else {
      alert(`Export complete. Successfully updated ${successCount}/${productsToExport.length} products in ERPNext.`);
    }

  } catch (err: any) {
    console.error('A general error occurred during export:', err);
    alert(`Export failed: ${err.message}. Please check your ERPNext connection settings.`);
  } finally {
    setLoading(false);
  }
}
