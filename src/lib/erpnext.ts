// This file is generated by Firebase Studio
'use client';

import type { Product } from './types';

// Helper function to call our new server-side proxy
async function erpNextRequest(
  endpoint: string,
  method: 'GET' | 'POST' | 'PUT' | 'PATCH' | 'DELETE' = 'GET',
  body?: any
) {
  const response = await fetch('/api/proxy-erpnext', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({ endpoint, method, body }),
  });

  if (!response.ok) {
    let errorMessage = `Request failed with status ${response.status}`;
    try {
        const errorText = await response.text();
        
        // Check if the response is HTML (like a Cloudflare error page)
        if (errorText.trim().startsWith('<!doctype html>')) {
            const $ = (await import('cheerio')).load(errorText);
            // Extract a more meaningful title or header from the HTML
            const pageTitle = $('title').text();
            const h2Title = $('h2').first().text();
            errorMessage = `${pageTitle || h2Title || 'Received an HTML error page.'}`;
        } else {
             // Try to parse it as JSON, as expected from the API
            const errorBody = JSON.parse(errorText);
            if (errorBody._server_messages) {
                 const serverMessage = JSON.parse(errorBody._server_messages)[0];
                 errorMessage = JSON.parse(serverMessage).message || serverMessage;
            } else {
                errorMessage = errorBody.message || errorBody.exception || errorBody.error || JSON.stringify(errorBody);
            }
        }
    } catch {
        // If any parsing fails, fallback to the status text
         errorMessage = `${errorMessage}: ${response.statusText}`;
    }
    const error = new Error(`ERPNext API error: ${errorMessage}`);
    (error as any).response = response;
    throw error;
  }
  
  // Handle cases with no content in response
  if (response.status === 204) {
    return null;
  }
  
  return response.json();
}

const ERPNEXT_ITEM_FIELDS = [
  'name', 'item_code', 'item_name', 'standard_rate', 'image', 'description', 'web_long_description', 'modified'
];

function pickDescription(item: any): string {
    return item.web_long_description?.trim() || item.description?.trim() || '';
}

function shouldOverwrite(erpModified: string, localProduct?: Product): boolean {
  if (!localProduct?.description) return true; // Always write if local description is empty
  if (!localProduct?.sourceModified) return true; // Always write if we don't have a source timestamp
  return new Date(erpModified).getTime() > new Date(localProduct.sourceModified).getTime();
}

// 2. Import produse din ERPNext
export async function importProductsFromERPNext(
  setLoading: (b: boolean) => void,
  setProducts: (fn: (products: Product[]) => Product[]) => void,
  currentProducts: Product[]
) {
  try {
    setLoading(true);

    let allItems: any[] = [];
    const pageSize = 100; // Fetch in batches of 100
    let start = 0;
    let hasMore = true;

    while (hasMore) {
      const endpoint = `/api/resource/Item?fields=${JSON.stringify(ERPNEXT_ITEM_FIELDS)}&limit_start=${start}&limit_page_length=${pageSize}`;
      const itemsData = await erpNextRequest(endpoint);
      
      if (itemsData && itemsData.data && itemsData.data.length > 0) {
        allItems = allItems.concat(itemsData.data);
        start += pageSize;
      } else {
        hasMore = false;
      }
    }

    if (allItems.length === 0) {
      alert('No products found in ERPNext to import.');
      setLoading(false);
      return;
    }

    // Create a map of existing products for quick lookup
    const productMap = new Map(currentProducts.map(p => [p.code, p]));
    let newCount = 0;
    let updatedCount = 0;

    const upsertedProducts = await Promise.all(allItems.map(async (item: any) => {
        const existingProduct = productMap.get(item.name);
        const erpNextUrl = process.env.NEXT_PUBLIC_ERPNEXT_URL || '';
        const imageUrl = item.image ? (erpNextUrl.replace(/\/$/, '') + item.image) : '';
        let qty = existingProduct?.quantity || 0;

        try {
            const binData = await erpNextRequest(`/api/resource/Bin?filters=[["item_code","=","${item.name}"]]&fields=["actual_qty"]`);
            qty = binData.data.reduce((acc: number, curr: any) => acc + curr.actual_qty, 0);
        } catch (err) {
            console.warn(`No Bin data for item ${item.name}`, err);
        }

        if (existingProduct) {
             // UPDATE logic
            if (shouldOverwrite(item.modified, existingProduct)) {
                updatedCount++;
                return {
                    ...existingProduct,
                    name: item.item_name || item.name,
                    price: item.standard_rate || 0,
                    image: imageUrl,
                    description: pickDescription(item),
                    sourceModified: item.modified,
                    quantity: qty,
                };
            }
            return existingProduct;
        } else {
            // CREATE logic
            newCount++;
            return {
                id: item.name,
                name: item.item_name || item.name,
                code: item.name,
                price: item.standard_rate || 0,
                quantity: qty,
                description: pickDescription(item),
                image: imageUrl,
                sourceModified: item.modified,
                supplier: '', location: '', tags: [], keywords: [], category: '',
                ebayCategoryId: '', listingStatus: 'draft', brand: '', productType: '', ean: '',
                technicalSpecs: {},
            } as Product;
        }
    }));


    setProducts(() => upsertedProducts);
    alert(`Import complete. ${newCount} new products added, ${updatedCount} products updated from ERPNext.`);
  } catch (err: any) {
    console.error(err);
    alert(`Import failed: ${err.message}`);
  } finally {
    setLoading(false);
  }
}

// 3. Update prețuri/stocuri/imagini din ERPNext
export async function updatePricesAndStocksFromERPNext(
  setLoading: (b: boolean) => void,
  setProducts: (fn: (products: Product[]) => Product[]) => void,
  currentProducts: Product[]
) {
  try {
    setLoading(true);

    if (!currentProducts.length) {
      alert('No products loaded in ListingFlow to update.');
      return;
    }

    let updatedCount = 0;
    const updatedProductsPromises = currentProducts.map(async (p: Product) => {
      let hasUpdate = false;
      
      try {
        const details = await erpNextRequest(`/api/resource/Item/${p.code}?fields=${JSON.stringify(ERPNEXT_ITEM_FIELDS)}`);
        const itemData = details.data;
        const newProductData = { ...p };

        const newPrice = itemData.standard_rate;
        if (newPrice !== undefined && newPrice !== p.price) {
          newProductData.price = newPrice;
          hasUpdate = true;
        }
        
        const erpNextUrl = process.env.NEXT_PUBLIC_ERPNEXT_URL || '';
        const newImage = itemData.image ? (erpNextUrl.replace(/\/$/, '') + itemData.image) : '';
        if (newImage && newImage !== p.image) {
            newProductData.image = newImage;
            hasUpdate = true;
        }
        
        if (shouldOverwrite(itemData.modified, p)) {
            newProductData.description = pickDescription(itemData);
            newProductData.sourceModified = itemData.modified;
            hasUpdate = true;
        }

        const binData = await erpNextRequest(`/api/resource/Bin?filters=[["item_code","=","${p.code}"]]&fields=["actual_qty"]`);
        const newQty = binData.data.reduce((acc: number, curr: any) => acc + curr.actual_qty, 0);
        if (newQty !== p.quantity) {
          newProductData.quantity = newQty;
          hasUpdate = true;
        }
        
        if(hasUpdate) updatedCount++;
        return newProductData;

      } catch (err) {
        console.warn(`Could not update details for ${p.code}`, err);
        return p; // Return original product on error
      }
    });
    
    const updatedProducts = await Promise.all(updatedProductsPromises);

    setProducts(() => updatedProducts);
    alert(`Update complete. ${updatedCount} products were updated with new data from ERPNext.`);
  } catch (err: any)
 {
    console.error(err);
    alert(`Update failed: ${err.message}`);
  } finally {
    setLoading(false);
  }
}


/**
 * Builds a comprehensive description string from product data,
 * including its base description and all technical specifications.
 * @param product The product object.
 * @returns A formatted string ready to be used as a description.
 */
const buildFullDescription = (product: Product): string => {
  let fullDescription = product.description || '';

  const specs = {
    'Marke': product.brand,
    'Produktart': product.productType,
    ...product.technicalSpecs,
  };

  const specEntries = Object.entries(specs)
    .map(([key, value]) => {
      if (!value) return null; // Skip if value is empty
      const formattedValue = Array.isArray(value) ? value.join(', ') : value;
      // Capitalize the first letter of the key
      const formattedKey = key.charAt(0).toUpperCase() + key.slice(1);
      return `${formattedKey}: ${formattedValue}`;
    })
    .filter(Boolean); // Remove null entries

  if (specEntries.length > 0) {
    fullDescription += '\n\n<hr>\n\n<h3>Technische Daten:</h3>\n<ul>\n';
    specEntries.forEach(entry => {
      fullDescription += `  <li>${entry}</li>\n`;
    });
    fullDescription += '</ul>';
  }

  return fullDescription.trim();
};


// 4. Export modificări către ERPNext
export async function exportProductsToERPNext(
  setLoading: (b: boolean) => void,
  productsToExport: Product[]
) {
  try {
    setLoading(true);

    if (!productsToExport.length) {
      alert('No products to export.');
      return;
    }

    let successCount = 0;
    let errorMessages: string[] = [];

    for (const p of productsToExport) {
        const fullDescription = buildFullDescription(p);

        const itemPayload: Record<string, any> = {
            item_name: p.name,
            standard_rate: p.price,
            description: fullDescription,
            web_long_description: fullDescription,
            ean: p.ean,
        };

        if(p.brand) {
            itemPayload.brand = p.brand;
        }

        try {
            await erpNextRequest(`/api/resource/Item/${p.code}`, 'PUT', { data: itemPayload });
            successCount++;
        } catch (error: any) {
             const message = `Failed to export product ${p.code}: ${error.message}`;
             console.error(message);
             errorMessages.push(message);
        }
    }

    if (errorMessages.length > 0) {
      alert(`Export partially complete. 
Successfully updated ${successCount}/${productsToExport.length} products.
Errors encountered:
- ${errorMessages.join('\n- ')}`);
    } else {
      alert(`Export complete. Successfully updated ${successCount}/${productsToExport.length} products in ERPNext.`);
    }

  } catch (err: any) {
    console.error('A general error occurred during export:', err);
    alert(`Export failed: ${err.message}`);
  } finally {
    setLoading(false);
  }
}


// 5. Universal Search Function
export async function searchInERPNext(
  doctype: string,
  filters: any[][],
  fields: string[],
  pageLength = 20,
  start = 0
): Promise<any[]> {
  try {
    // The standard API does not support OR filters, it treats arrays of filters as AND.
    // To simulate an OR, we have to make separate requests and combine the results.
    const requests = filters.map(filter => {
       const endpoint = `/api/resource/${doctype}?filters=${JSON.stringify([filter])}&fields=${JSON.stringify(fields)}&limit_start=${start}&limit_page_length=${pageLength}`;
       return erpNextRequest(endpoint);
    });

    const responses = await Promise.all(requests);
    const allResults = responses.flatMap(resp => resp.data || []);
    
    // Remove duplicates based on the 'name' field, which is the unique ID in ERPNext
    const uniqueResults = allResults.filter((item, index, self) =>
        index === self.findIndex((t) => t.name === item.name)
    );

    return uniqueResults;
  } catch(err) {
    console.error(`Search in ${doctype} failed:`, err);
    // Return empty array in case of error to avoid breaking the UI
    return [];
  }
}